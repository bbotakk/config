ls
cd .config/
$env | reject config | transpose key val | each {|r| echo $"let-env ($r.key) = '($r.val)'"} | str join (char nl)
chsh
bat /etc/shells
man chsh 
sudo chsh -s /usr/bin/nu
chsh -s /usr/bin/nu
$env.path
$env.PATH
help split
lfcd
clear
lf
nvim
hello
ls
ls | get name
ls | drop name
ls | sort-by size
ls -la
exa
ls
exa -la
exa -la | get 
exa -la | get Archive/
exa -la | get Archive
exa -la | get
exa -la | get date
exa -la
man nu
help get
$env.config
$env.config.hooks
$env.config.hooks.env_chang
$env.config.hooks.env_change
$env.config | select hooks
$env.config | get hooks
help get
help select
help pick
help upsert
help path
path split /home/bo
path split
/home/bo | path split
'/home/bo' | path split
'/home/bo' | path split | warp
help transpose
help path
help path join
'~/' | path exists
explore
explore \i
explore -i
help path expand
help split row
help append
['hello'] | append ['world', 'hey']
keybindings list
source ~/.config/nushell/config.nu
mktemp
let temp = (mktemp)
$temp
ls
;find
find
fd
source ~/.config/nushell/env.nu
$nu.scope.aliases
source ~/.config/nushell/env.nu
(EDITOR)
source ~/.config/nushell/env.nu
mkdir -h
source ~/.config/nushell/env.nu
ls
help into
ls
command ls
which ls
(ls)
yay xfce4-pow
yay xfce4-scree
startup.fish
help path exists
help path
help file
$pwd
pwd
def lfcd [] {<\n>    let tmp = (mktemp)<\n>    lf -last-dir-path=$tmp<\n>    if ($tmp | path exists) {<\n>        let dir = (cat $tmp)<\n>        rm -f $tmp<\n>        if ($dir | path exists) {<\n>            if ($dir != (pwd)) {<\n>                cd $dir<\n>            }<\n>        }<\n>    }<\n>}
lfcd
lf
"lf"
lf
source ~/.config/nushell/env.nu
lf
$nu$nu.scope.aliases
$nu.scope.aliases
help hide
help list
$nu.scope.aliases
$nu.scope.aliases | get 1
$nu.scope.aliases | reject lf
$nu.scope.aliases | reject 11
soursource ~/.config/nushell/env.nu
source ~/.config/nushell/env.nu
lf
source ~/.config/nushell/env.nu
lf$nu.scope.aliases
$nu.scope.aliases
lf
lf 
lf
lfcd
def lfcd [] {<\n>    let tmp = (mktemp)<\n>    lf -last-dir-path=$tmp<\n>    if ($tmp | path exists) {<\n>        let dir = (cat $tmp)<\n>        rm -f $tmp<\n>        if ($dir | path exists) {<\n>            if ($dir != (pwd)) {<\n>                cd $dir<\n>            }<\n>        }<\n>    }<\n>}
lfcd
man rm
help rm
man rm
source ~/.config/nushell/env.nu
rm
lfcd
def lfcd [] {<\n>    let tmp = (mktemp)<\n>    lf -last-dir-path=$tmp<\n>    if ($tmp | path exists) {<\n>        let dir = (cat $tmp)<\n>        rm -f $tmp<\n>        if ($dir | path exists) {<\n>            if ($dir != (pwd)) {<\n>                cd $dir<\n>            }<\n>        }<\n>    }<\n>}
lfcd
lfrd
lfcd
def lfcd [] {<\n>    let tmp = (mktemp)<\n>    lf -last-dir-path=$tmp<\n>    if ($tmp | path exists) {<\n>        let dir = (cat $tmp)<\n>        rm -f $tmp<\n>        if ($dir | path exists) {<\n>            if ($dir != (pwd)) {<\n>                cd $dir<\n>            }<\n>        }<\n>    }<\n>}
lfcd
cat (mktmp)
cat (mktemp)
man ip
def lfcd [] {<\n>    let tmp = (mktemp)<\n>    lf -last-dir-path=$tmp<\n>    if ($tmp | path exists) {<\n>        let dir = (cat $tmp)<\n>        rm -f $tmp<\n>        if ($dir | path exists) {<\n>            if ($dir != (pwd)) {<\n>                cd $dir<\n>            }<\n>        }<\n>    }<\n>}
lfcd
man lf
let temp = (mktemp) 
cat temp
cat $temp
 $temp
    let tmp = (mktemp)
    lf -last-dir-path=$tmp
    let dir = (cat $tmp)
    rm -f $tmp
    cd $dir
}
def lfcd [] {<\n>    let tmp = (mktemp)<\n>    lf -last-dir-path=$tmp<\n>    let dir = (cat $tmp)<\n>    rm -f $tmp<\n>    cd $dir<\n>}
lfcd
let tmp = (mktemp)
tmp 
cat $tmp
lf -last-dir-path=$tmp
cat $tmp
touch test
cat test
lf -last-dir-path=~/test
cat test
cat <test
man mkdir
def md [dir: string] {<\n>    mkdir -v $dir && cd $dir<\n>}
def md [dir: string] {<\n>    mkdir -v $dir cd $dir<\n>}
def md [dir: string] {<\n>    mkdir -v $dir<\n>    cd $dir<\n>}
md ass
def md [dir: string] {<\n>    mkdir -v $dir<\n>    echo $dir<\n>    cd $dir<\n>}
md ass
ls
md a
ls
:tring] {<\n>    # mkdir -v $dir<\n>    print $dir<\n>    cd $dir<\n>}
def md [dir: string] {<\n>    # mkdir -v $dir<\n>    print $dir<\n>    cd $dir<\n>}
md b
:tring] {<\n>    mkdir -v $dir<\n>    print $dir<\n>    cd $dir<\n>}
def md [dir: string] {<\n>    mkdir -v $dir<\n>    print $dir<\n>    cd $dir<\n>}
md b
ls
def md [dir: string] {<\n>    let tomake = $dir<\n>    print $tomake<\n>    # mkdir -v $tomake<\n>    # cd $tomake<\n>}
md a
md o
ls
def md [dir: string] {<\n>    let tomake = $dir<\n>    print $tomake<\n>    mkdir -v $tomake<\n>    cd $tomake<\n>}
md e
ls
mkdir -v b
ls
def md [dir: string] {<\n>    mkdir $dir<\n>    cd $dir<\n>}
md ee
cd ee
def md [inp: string] {<\n>    const dir = $inp<\n>    mkdir $dir<\n>    cd $dir<\n>}
print 12
print 12; print 23
        print "Usage: extract path/file_name.{zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz}"
        print Usage: extract path/file_name.{zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz}
def extract [<\n>    files: list<\n>    --help (-h)<\n>        ] {<\n>    for file in $files {<\n>        if not ($file | path exists) {<\n>            print "Error: Files were wrongly input"<\n>            print "Input them as follows:"<\n>            print "     extract path/file_name.{zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz}"<\n>            print "     extract path/file_name_1.ext [path/file_name_2.ext] [path/file_name_3.ext]"<\n>            return<\n>            }<\n>        }<\n><\n>    print "success"<\n>    }
extract [~/, /home]
extract [~/, /ome]
help to
help split
'~/ /home /etc' | split row
'~/ /home /etc' | split row ' '
yay alacritty
yay zelli
yay starship
1 in [1,2]
1 in [1,2, *]
3 in [1,2, *]
3 in [1,2, '*']
7z
keybindings list
fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*'
cd ..
fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*'
cd (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
man ls
ls --group-directorys-first --color
ls -group-directorys-first --color
man ls
ls --group-directories-first --color
ls -ls --group-directories-first
ls --group-directories-first
help ls
ls
ls -l
keybindings list
man print
man echo "hello world"
$nu.env.PATH
$nu.env.path
$nu.env-path
source ~/.cache/starship/init.nu
yay starship
starship
starship prompt
starship preset no-nerd-font -o ~/.config/starship.toml
mkdir ~/.cache/starship
starship init nu | save -f ~/.cache/starship/init.nu
source ~/.cache/starship/init.nu
starship preset no-nerd-font -o ~/.config/starship.toml
ls
yay -Rs starship
yay starship
ls
man
manecho 
manecho
this
great
echo hello
cd ..
.config
ls
neci
this 
ls
man starship 
starship
starship-h
starship -h
ping google.com
starship preset plain-text-symbols -o ~/.config/starship.toml
ls
cd ..
full_line_prompt.nu
~/.config/nushell/scripts/full_line_prompt.nu
exe full_line_prompt.nu
exe ~/.config/nushell/scripts/full_line_prompt.nu
~/.config/nushell/scripts/full_line_prompt.nu
nu ~/.config/nushell/scripts/full_line_prompt.nu
cd (fd --hidden -t d | fzf)
ls
man echo 
zellij
ls
e
alacritty
echo 'hello' &| less
yay zoxide
sudo pacman -S zoxide
sudo pacman -Syi
wmctrl -xa firefox || firefox
try {wmctrl -xa firefox}; catch {firefox}
try {wmctrl -xa firefox}; catch {kitty}
try {wmctrl -xa Yirefox}; catch {kitty}
cargo
let command = 'firefox'
wmctrl -xa $command or $command
if (wmctrl -xa $command) {}; else {$command}
wmctrl -xa $command
wmctrl -xa firefox or print ass
wmctrl -xa xirefox or print ass
wmctrl -xa xirefox or (print ass)
ls
great this is
print hello 
ls
keybindings list
nu
nu
ls
echo  &| less
wmctrl -x firefox
wmctrl -a firefox
wmctrl -x firefox
cargo install nu
man wmctrl 
man try (ee) or print hello
man 
man try (ee) or (print hello)
sudo pacman -Syu 
man try {ee} or {print hello}
try
help triy
remaps.fish
help nu
help try
try {wmctrl -xa Firo} catch {wmctrl -xa firefox}
try {wmctrl -xa Firo} catch {wmctrl -xa kitty}
try {wmctrl -xa Firo} catch {wmctrl -xa kitty}(fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
try {wmctrl -xa Firo} catch {wmctrl -xa kitty}
try {eee} catch {wmctrl -xa kitty}
try {eee} catch {kitty}
exe (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
pgrep polybar
nu
nu
nu
nu
nu
nu
nu
nu
fish
fish
fish
fish
nu
nu
fish
fish
fish
pgrep polybar | complete
pgrep polybar | complete.exit_code
pgrep polybar | complete | get exit_code
xrandr
xrandr --query
help string
help split
xrandr --query | split row
xrandr --query | split row ' '
xrandr --query | split column 
xrandr --query | split column '\n'
xrandr --query | split
xrandr --query | split chars
xrandr --query 
xrandr --query | parse '{name} {status}'
xrandr --query | row
help parse
xrandr --query | detetct columns
xrandr --query | detect columns
xrandr --query | split row '\n'
xrandr | split row '\n'
xrandr | split column '\n' 
xrandr | split column '\n' | get \1
xrandr | split column '\n' | get -1
help get
xrandr | split column '\n' 
xrandr | split row '\n' 
xrandr | split row '\n' | get 0
xrandr | split row '\n' | get 0.1
help from
help from-lines
xrandr | from-lines
help lines
xrandr | lines
xrandr | lines | detect columns
xrandr | lines <\n>
<\n>xrandr | lines | where {|i| $i =~ ' connected'}<\n> 
help drop
help last
xrandr | lines | where {|i| $i =~ ' connected'}
help str
xrandr | lines | where {|i| $i =~ ' connected'} | split words
xrandr | lines | where {|i| $i =~ ' connected'} | split words | get 0
xrandr | lines | where {|i| $i =~ ' connected'} | split words 
xrandr | lines 
xrandr | lines | split words
xrandr | lines | where {|i| $i =~ ' disconnected'} | split words 
xrandr | lines | where {|i| $i =~ ' disconnected'} 
xrandr | lines | where {|i| $i =~ ' disconnected'} | parse  
help detect
help detect columns
xrandr | lines | where {|i| $i =~ ' disconnected'} | detect columns
xrandr | lines | where {|i| $i =~ ' disconnected'} 
xrandr | lines | where {|i| $i =~ ' disconnected'} | detect columns  
xrandr | lines | where {|i| $i =~ ' disconnected'} | split column ' '
xrandr | lines | where {|i| $i =~ ' disconnected'} | split column 
xrandr | lines | where {|i| $i =~ ' disconnected'} | split column esep
xrandr | lines | where {|i| $i =~ ' disconnected'} | split column (esep)
help esep
e
help esep
help for
help for |less
help for &|less
xrandr | lines | where {|i| $i =~ ' disconnected'} | split column  ' '
help get 
xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1
help where 
ls | where
ls 
help each
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    MONITOR=$monitor polybar --reload main -c ~/.config/polybar/config.ini &<\n>}
polybar_launcher.nu
exe (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
polybar_launcher.nu
nu (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
help sleep
nu (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
disown 
disown echo 'hel' 
nohup echo 'hel' 
man nohup
man bash 
nu (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    print $monitor<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    bash -c "MONITOR=eDP-1 polybar --reload main -c ~/.config/polybar/config.ini &" # workaround using bash since nushell does not have `&` operator.<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    print $monitor<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    echo "$monitor"<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    echo "($monitor)"<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    echo $monitor<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    print $monitor<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    echo $monitor<\n>}
help print
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    let mon = monitor<\n>    bash -c "MONITOR=($mon) polybar --reload main -c ~/.config/polybar/config.ini &" # workaround using bash since nushell does not have `&` operator.<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    let mon = monitor<\n>    echo "$mon"<\n>    # bash -c "MONITOR=$mon polybar --reload main -c ~/.config/polybar/config.ini &" # workaround using bash since nushell does not have `&` operator.<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    let mon = monitor<\n>    echo "$mon"<\n>    print $mon<\n>    # bash -c "MONITOR=$mon polybar --reload main -c ~/.config/polybar/config.ini &" # workaround using bash since nushell does not have `&` operator.<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    let mon = $monitor<\n>    echo "$mon"<\n>    print $mon<\n>    # bash -c "MONITOR=$mon polybar --reload main -c ~/.config/polybar/config.ini &" # workaround using bash since nushell does not have `&` operator.<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    let mon = $monitor<\n>    print $mon<\n>    # bash -c "MONITOR=$mon polybar --reload main -c ~/.config/polybar/config.ini &" # workaround using bash since nushell does not have `&` operator.<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    let mon = $monitor<\n>    echo "$mon"<\n>    # bash -c "MONITOR=$mon polybar --reload main -c ~/.config/polybar/config.ini &" # workaround using bash since nushell does not have `&` operator.<\n>}
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    let mon = $monitor<\n>    echo "($mon)"<\n>    # bash -c "MONITOR=$mon polybar --reload main -c ~/.config/polybar/config.ini &" # workaround using bash since nushell does not have `&` operator.<\n>}
man echo
bash
ps xa poly
ps
man ps 
ps ax 
man ps 
ps
ps | get name 
ps | get name | where {|i| $i =~ firefox}
ip
ip addr
date
date now 
date format 
date to-table 
date |date to-table 
date now |date to-table 
help length
ps | get name | where {|i| $i =~ firefox} | length
ps | get name | where {|i| $i =~ Firefox} | length
let prgr = "fireforx" 
print "$prgr hello"
print "($prgr) hello"
print "(prgr) hello"
print $prgr hello
help print 
print -n $prgr hello
print -n $prgr ' ' hello
echo 'ehll' | bash -c
bash -c (print hello)
bash -c (print hello | to-string)
bash -c (print hello | into string)
help find
find . ~/.config/scripts/nushell/
find ~/.config/scripts/nushell/
find '.*' ~/.config/scripts/nushell/
find ~/.config/scripts/nushell
find
help find
help ls
fd
fd ~/.config/scripts/nu | lines
fd ~/.config/scripts/nushell | lines
fd ~/.config/scripts/nushell 
fd '~/.config/scripts/nushell'
fd . '~/.config/scripts/nushell'
fd . '/home/bo/.config/scripts/nushell'
fd -e nu
fd . -e nu
fd -e nu --hidden
fd -e nu --hidden | lines
help fd -e nu --hidden | lines 
help lines
help fd -e nu --hidden | lines 
fd -e nu --hidden | lines 
fd --hidden -e nu '~/.config' | lines
fd --hidden -e nu '/home/bo/.config' | lines
fd --hidden -e nu . '/home/bo/.config' | lines
fd --hidden -e nu . '/home/bo/.config' | lines | each {|i| exe $i}
fd --hidden -e nu . '/home/bo/.config' | lines | each {|i| chmod +x $i}
mut x: bool = 1
mut x = 1
let x = 1
x == true
x == 2
x = 2
(x == 2)
$x
$x == true
polybar_launcher.nu
nu polybar_launcher.nu
nu (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
let x = 1
bash -c $"echo $x"
$x
echo $"($x) is a numeber"
bash -c $"echo ($x) is a number"
polybar_launcher.nu
$env.path
$env.PATH
char 
help split char 
help split
help split chars
source ~/.config/nushell/env.nu
$env.PATH
polybar_launcher.nu
echo 'hell' | bash
echo 'echo hello' | bash
 'echo hello' | bash
 'echo hello &' | bash
for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>    $"MONITOR=($monitor) polybar --reload main -c ~/.config/polybar/config.ini &" | bash # workaround using bash since nushell does not have `&` operator.<\n>}
ps
nu
firefox in (ps | get name)
(firefox in (ps | get name))
print (firefox in (ps | get name))
print ("firefox" in (ps | get name))
("firefox" in (ps | get name))
help ("firefox" in (ps | get name))
help in
let list = [firefox ee a foo]
firefox in $list
"firefox" in $list
ps | get name | str join 
ps | get name | str collect
ps | get name 
help str contains
ps | get name | str contains 'firefox'
ps | get name | str collect <\n>| str contains 'firefox' 
ps | get name | str collect | str contains 'firefox' 
ps | get name | str join | str contains 'firefox' 
help table
help list
help table
help List
help table
table -l
help array
ps | get name | str contains 'firefox' 
true in (ps | get name | str contains 'firefox')
help reduce 
ps | get name | str contains 'firefox' | reduce {|it| $it}<\n>
ps | get name | str contains 'firefox' | reduce {|it| $it == true}<\n>
ps | get name | str contains 'firefox' | reduce {|it| $it == false}<\n>
ps | get name | str contains 'firefox' | str contains true<\n>
ps | get name | str contains 'firefox' | str contains 'true'<\n>
ps | get name | str contains 'firefox' | table --flatten <\n>
help fold
help map
help duration
help time
time
date
duration
    let dir= ~/.local/share/time<\n>    let buffer = $dir 'time' | str join<\n>    $buffer
    let dir = ~/.local/share/time<\n>    let buffer = $dir 'time' | str join<\n>    if not ($dir | path exists) {mkdir $dir}
let dir = ~/.local/share/time<\n>let buffer = ($dir 'time' | str join)<\n>if not ($dir | path exists) {mkdir $dir}
help str
nu
    let dir = ~/.local/share/time<\n>  let buffer = $"($dir)time"
$buffer
    let dir = ~/.local/share/time/<\n>  let buffer = $"($dir)time"
$buffer
    if not ($dir | path exists) {<\n>        mkdir $dir<\n>        print sucess<\n>    }
$dir
$dir| path exists
$dir | path exists
$dir
$dir | path exists
mkdir $dir 
$dir | path exists
ls $dir
    let dir = ~/.local/share/timer
    let buffer = $"($dir)/buffer"
    if not ($dir | path exists) {<\n>        mkdir $dir<\n>    } 
$dir
$dir | path exists
help path
~/.config | path exists
'~/.config' | path exists
    let dir = '~/.local/share/timer'
    let buffer = $"($dir)/buffer"
    if not ($dir | path exists) {<\n>        mkdir $dir<\n>    } 
$dir
$dir | path exists
print $dir | path exists
echo $dir | path exists
echo $dir 
~/.local/share/timer
'~/.local/share/timer' | path exists
'~/.local/share/timer' | mkdir
mkdir ~/.local/share/timer
mkdir '~/.local/share/timer'
    if not ($dir | path exists) {<\n>        mkdir $dir<\n>    } 
cat .xonshrc.2023-05-08-19-38-19-942361
bat .xonshrc.2023-05-08-19-38-19-942361
open .xonshrc.2023-05-08-19-38-19-942361
open .xonshrc.2023-05-08-19-38-19-942361 | tabel
open .xonshrc.2023-05-08-19-38-19-942361 | table
man notify-send 
seq -1 1
help duration
100 | into duration
100sec | into duration
100h | into duration
100hr | into duration
100min |into duration
help into 
help into string
help into duration
1h 30min |into duration
30min |into duration
30h |into duration
30hr |into duration
1hr 30min |into duration
1hr + 30min |into duration
1hr  |into duration
1.5h |into duration
1.5hr |into duration
duration
help save
let test: bool = true 
let test = true 
if $test {echo 'hello'}
if not $test {echo 'hello'}
sleep 1s
sleep 1sec
printf
printf --help
print
help print
printf "%s" 'hello'
printf "%s: %s" 'hello' 'ass'
print "%s: %s" 'hello' 'ass'
help duration
help convert
man seq
help convert
help duration
help into duration
e
source ~/.config/nushell/config.nu
(fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
e (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
e
e (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
e
e (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
e
e (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
e
e (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf )
e
let dur = 1min
mut dur = 1min
$dur = $dur + 1min
$dur 
$dur = $dur + 2hr
$dur 
time
timer
help timer
timer
lf
clear
ls
ls -la
ls -la | where type == file
cd Music
dirs prev
help std
std dirs
std 
help std
use std
dirs prev
std dirs prev
std dirs next
cd ~
std dirs prev
std dirs next
use std
hide std
std dirs next
use std
std dirs next
keybindings list
nvim
e
help path join
let-env NU_LIB_DIRS = [<\n>    ($nu.default-config-dir | path join 'scripts')<\n>    ($nu.default-config-dir | path join 'themes')<\n>]
source solarized_light.nu
source solarized_dark.nu
help use
source use
help source
$NU_LIB_DIRS
let-env NU_LIB_DIRS = [<\n>    ($nu.default-config-dir | path join 'scripts')<\n>]
NU_LIB_DIRS
$NU_LIB_DIRS
source $nu.config-path
$nu.config-path
source "$$nu.config-path/env.nu"
source $"$nu.config-path/env.nu"
source "~/.config/nushell/env.nu"
source "~/.config/nushell/scripts/solarized.nu"
source "~/.config/nushell/scripts/extract.nu"
k
source "~/.config/nushell/scripts/extract.nu"
source $"$nu.default-config-dir/solarized.nu"
source "solarized.nu"
$env.PATH
ls
l
ls
ls -la
l
$env.PATH
$env.PATH | split row
$env.PATH | split row ' '
$env.PATH | split row (esep)
$env.PATH | split row (char esep)
$env.PATH 
$env.PATH | split row (char esep)
$env.PATH 
help $env.PATH | upsert
help usert 
help upsert
help append 
let action = true
if $action == true {<\n>print 't'}
help let 
help set 
help help set 
help mut
help const
let x = 1
mut x = 
mut x = 1
$x -= 1
$x
help path 
help path join
timeup
help type
timeup
0min <= 1h
0min <= 1hr
timeup
timeup start timer 60min
timeup stop
timeup -t start timer 60min
timeup check
ls
timeup check
timeup start stopwatch 
timeup check
timeup start stopwatch 
let d = 1min<\n>while $d >= 0sec {<\n>    print 'f'<\n>    $d -= 1sec<\n>}
mut d = 1min<\n>while $d >= 0sec {<\n>    print 'f'<\n>    $d -= 1sec<\n>}
mut d = 1min<\n>while $d >= 0sec {<\n>    print 'f'<\n>    sleep 1sec<\n>    $d -= 1sec<\n>}
def pass [duration: duration] {<\n>    mut duration = $duration<\n>    while $duration >= 0sec {<\n>        print 'f'<\n>        sleep 1sec<\n>        $d -= 1sec<\n>    }<\n>}
def pass [duration: duration] {<\n>    mut duration = $duration<\n>    while $duration >= 0sec {<\n>        print 'f'<\n>        sleep 1sec<\n>        $duration -= 1sec<\n>    }<\n>}
pass 10sec
timeup start stopwatch 
timeup check
    let dir = '~/.local/share/timeup'
    let buffer = ( $dir | path join 'timeup')
    if not ( $dir | path exists ) { mkdir $dir } 
$dir
$dir | path exists
not ($dir | path exists)
mkdir $dir
not ($dir | path exists)
mkdir $dir |complete
mkdir $dir 
ls $dir
$dir | path exists
mkdir ~/.local/share/timeup
help mkdir
$dir | mkdir
^mkdir $dir
sudo ^mkdir $dir
sudo mkdir $dir
mkdir ($dir | into string)
^mkdir ($dir | into string)
^mkdir $dir
mkdir $dir
let $dir = conf
mkdir $dir
let $dir = ~/.local/share/timeup
mkdir $dir
mkdir ~/.local/share/timeup/
    let dir = '~/.local/share/timeup/'
    let buffer = ( $dir | path join 'timeup')
$buffer
touch $buffer
$buffer |path exists
mkdir $dir
$dir
mkdir $dir
let $dir = ~/.local/share/timeup/
mkdir $dir
let $dir = ~/.local/share/timeup
mkdir $dir
let $dir = ~/.local/share/timeup/
mkdir $dir
let $dir = ~/.local/share/timeup/
^mkdir $dir
lf
    let buffer = ~/.local/share/timeup
$buffer
touch $buffer
fish
    let buffer = ~/.local/share/timeup
touch $buffer
$buffer | path exists
^mkdir $buffer
    let buffer = ~/.local/share/timeup.tmp
$buffer
touch $buffer
$buffer | path exists
$buffer 
ls ~/.local/share
touch $buffer
touch ($buffer | into string )
let $b = temp
touch $b
$b |path exists
let $b = ~/.local/share/temp
touch $b
    let buffer = ~/.local/share/timeup
let b = .temp
touch $b
timeup check
timeup start stopwatch
cat .timeupbuffer
timeup start stopwatch
help save
timtimeup check
timeup check
timeup start stopwatch
timeup check
timeup 
timeup start
help timeup
timeup help
timeup -h
yay kigo
sudo pacman -Qs kigo
sudo pacman -Rs kigo 
sudo pacman -Qs chess
sudo pacman -Rs knights gnuchess gnome-chess 
remaps 
timeup
timeup -h
timeup help
help timeup
timeup -h
lf
timeup
timeup check
timeup start stopwatch
let b = ~/.local/share/timeup
"timer" | save $b
$b
help save
$b
$b
help touc
help touch
touch $b
let b = ~/.local/share/timeup.buf
$b
touch $b
man touch
help save
'aa' | save ~/test
l
ll
ls
bat test
'aa' | save ~/.local/test
'aa' | save ~/.local/share/test
let b = ~/.local/share/test
'aa' | save $B
'aa' | save $b
help type
$b | path type 
$b | path type
$b | path type | print
$b | into string 
'oo' | save ($b | into string)
let b = .timeup
'aa' | save $b
let b = /home/bo/.local/share/.timeup
let b = /home/bo/.local/share/timeup/timeup
let b = /home/bo/.local/share/timeup/buffer
'aa' | save $b
cd $b
$b
mkdir /home/bo/.local/share/timeup
'aa' | save $b
$HOME
let b = /tmp/timeupbuffer
'aa' | save $b
timeup check
timeup start stopwatch
let b = /tmp/timeupbuffer
rm $Ub
rm $b
touch $b
rm $b
help assert
use std
help assert
use std
help std assert 
timeup start stopwatch
let b = /tmp/timeupbuffer
assert ($b | path exists)
assert 1 == true
std assert 1 == true
assert
timeup start stopwatch
std assert 1 == true
std assert false == true
std assert (false == true)
std assert (true == true)
timeup start stopwatch
$b
touch $b
$b | path exists
timeup start stopwatch
timeup check
timeup -t start stopwatch
let b = ~/timeup
touch $b
touch $"$b"
ls
timeup check
timeup -t start timer 60min
timeup check
timeup stop
timeup check
timer
timetrack 
timetrack -h
clear
timetrack -h
timetrack check
timetrack -t start stopwatch
timetrack -tv start stopwatch
timetrack -tq start stopwatch
timetrack check
timetrack -tqv start stopwatch
ls
~/.config/scripts/focus tui htop 'htop'
clementine
~/.config/scripts/focus tui pulsemixer 'pulsemixer'
help try
try { eh} catch { print 'f' }
~/.config/scripts/focus tui pulsemixer 'pulsemixer'
~/.config/scripts/focus gui pulsemixer 'pulsemixer'
pulsemixer
~/.config/scripts/focus gui pulsemixer 'pulsemixer'
~/.config/scripts/focus gui pulsemixer pulsemixer
pulsemixer
~/.config/scripts/focus tui pulsemixer 'pulsemixer'
echo 'hello' | exit_code
echo 'hello' | complete | exit_code
'hello' | complete | exit_code
print 'hello' | complete | exit_code
pgrep polybar | complete | exit_code
use std
exit_code
help exit_code
 pgrep polybar | complete | exit_code 
$env.LAST_EXIT_CODE
pgrep polybar
$env.LAST_EXIT_CODE
o
$env.LAST_EXIT_CODE
echo 
$env.LAST_EXIT_CODE
echo 'a'; $env.LAST_EXIT_CODE
cho 'a'; $env.LAST_EXIT_CODE
help complete
echo 'a' | complete
print 'a' | complete
print 'a' err
print 'a' | err
obsidian
'obsidian' | bash
pulsemixer
~/.config/scripts/focus tui pulsemixer 'pulsemixer'
help focus 
focus -h
timetrack -h
timetrack
ls
bat ~/.config/nushell/history.txt
bat ~/.config/nushell/history.txt | fzf
man fzf
bat ~/.config/nushell/history.txt | fzf --preview='bat'
man bat
(fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --preview='bat -f' )
fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --preview='cat'
man cat 
man bat
man fzf
help fzf
nu
nu
nu
fish;timetrack
man echo
help for
man fzf
ls
( cat ~/.config/nushell/history.txt | fzf --tac --reverse )
nu
this
exec "nu ls"
ls
nu
nvim
e
cd ~
( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse )
mv timetrack timer
timer start 
timer start timer 
man nothing 
help man nothing 
help nothing
nothing
help nothing
timer start timer 
let b
timer start timer 
help not
not
for
not
if not
man if
help if
not false
timer start timer 
timer start
timer 
help timer start 
timer -h
timer start timer 
timer start timer 25
timer start timer 25min
timer -t start timer 25min
timer -t start timer 5min
timer start stopwatch
timer -t start stopwatch
timer -tv start stopwatch
timer -t start stopwatch
timer -tv start stopwatch
man notify-send
timer stop
help str
help string
'hello World' | str kebab-case
'hello World' | str snake-case
help list
'hello World' | split words
'hello World' | split words | get 1
'holl: aoeu' | str trim ':'
man str trim
help man str trim
help  str 
help  str trim
'holl: aoeu' | str trim -c ':'
'holl= aoeu' | str trim -c '='
'holl = aoeu' | str trim -c '='
help str trim 
 
j
'holl = aoeu' | sed 's/://g'
'holl : aoeu' | sed 's/://g'
help split 
help get
'al et dal' | split words | get 0
'al et dal' | split words | get 0..
'al et dal' | split words | get 0..2
'al et dal' | split words | get 0.2
help get 
'al et dal' | split words 
help str
'al et dal' | split words | get 1 2 
help dfr get
help  get
drop
help drop
'al et dal' | split words | skip 1
'al: et dal' | split words | skip 1
'al: et dal' | split words 
'al: et dal' | split words | skip 1
'timer: 1hr' | split words | skip 1
'timer: 1hr' | split words 
split
'timer: 1hr' | split row 
'timer: 1hr' | split row ' '
'timer: 1hr 30min 2sec' | split row 
'timer: 1hr 30min 2sec' | split row ' ' | skip 1
'timer: 1hr 30min 2sec' | split row ' ' | skip 1 |print
'timer: 1hr 30min 2sec' | split row ' ' | skip 1 | echo
'timer: 1hr 30min 2sec' | split row ' ' | skip 1 | str join
'timer: 1hr 30min 2sec' | split row ' ' | skip 1 | str join ' '
help str collect
timer start -t
$env.VISUAL
$env.EDITOR
$env
ls
focus -h
man tmux 
tmux list
tmux list-keys
man alacritty 
alacritty --class 'editor'
man kitty 
sudo pacman -Rs neofetch
exti
zellij
pgrep polybar
pgrep polybar; $env.LAST_EXIT_CODE
pgrep
man pgrep
pgrep olybar; $env.LAST_EXIT_CODE
pgrep baoeuaoeuar; $env.LAST_EXIT_CODE
help break
git commit
rm ~/.config/.git/index.lock
polybar_launcher.nu
polybar_launcher
focus tui editor nvim
focus gui Clementine clementine
zellij setup
man zellij 
exe ( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse )
cd ..
alacritty -e 'bat .Xresources'
alacritty -e 'bat ~/.Xresources'
bat .Xauthority
bat .xsession-errors
alacritty -e 'bat .xsession-errors'
alacritty -e 'bat ~/.xsession-errors'
alacritty -e 'less ~/.xsession-errors'
less ~/.xsession-errors
bat .xsession-errors
alacritty -h
alacritty -e bat
alacritty -e 'echo hello'
alacritty --name terminal -e "tmux attach-session -t terminal"
e
fish
fish
nu
nu
nu
nu
nu
nu
nu
nu
nu
nu
nu
nu
nu
nu
nu
nu
nu
nu
clear
zellij
vim
vi
nvim
mkdir ~/.config/zellij
zellij setup --dump-config > ~/.config/zellij/config.kdl
zellij setup --dump-config | save -f ~/.config/zellij/config.kdl
bat ~/.config/zellij/config.kdl
$env.SHELL
man nu
help nu
e
ls
bat
ls
tmux
ls
zellij
aoeu
aou
e
ls
clear
nu
ls
( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse )
ls
thsi
hello                                 
                                
snoh
nvim
e
sl
ls
tmux
remaps
nvim
ls
this
remaps
xcape -e 'Alt_L=Escape'
remaps 
remaps
startup
ps | get name | str contains firefox
true in (ps | get name | str contains firefox)
startup
xfce4-power-manager
xsetroot -solid #002b36
xsetroot -solid 002b36
xsetroot -solid #002b36
xsetroot -solid '#002b36'
xsetroot -solid "#002b36"
polybar_launcher 
for monitor in ( xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column 1 ) {<\n>    $"MONITOR=($monitor) polybar --reload main -c ~/.config/polybar/config.ini &" | bash # workaround using bash, to launch bars as subprocesses. (nushell does not support background processes yet...)<\n>}
( xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column 1 )
( xrandr | lines | where {|i| $i =~ ' connected'} | split column )
( xrandr | lines | where {|i| $i =~ ' connected'} | split column ' ' )
( xrandr | lines | where {|i| $i =~ ' connected'} | split column ' ' | get column1)
 xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1 
for monitor in ( xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1 ) {<\n>    $"MONITOR=($monitor) polybar --reload main -c ~/.config/polybar/config.ini &" | bash # workaround using bash, to launch bars as subprocesses. (nushell does not support background processes yet...)<\n>}
startup
for monitor in ( xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1 ) {<\n>    $"MONITOR=($monitor) polybar --reload main -c ~/.config/polybar/config.ini &" | bash # workaround using bash, to launch bars as subprocesses. (nushell does not support background processes yet...)<\n>}
killall -q polybar
polybar-msg cmd quit
polybar_launcher 
killall -q polybar
# Wait until the processes have been shut down
while true {<\n>    pgrep polybar<\n>    if $env.LAST_EXIT_CODE == 1 { sleep 1sec } else { break }<\n>}
for monitor in ( xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1 ) {<\n>    $"MONITOR=($monitor) polybar --reload main -c ~/.config/polybar/config.ini &" | bash # workaround using bash, to launch bars as subprocesses. (nushell does not support background processes yet...)<\n>}
polybar_launcher
startup
e
ls
clear
ls
tree
zellij
man zellij
zellij
zellij 
zellij -d
zellij -h
ls
tree
tmux man
zellij
ls
man tmux
zellij setup --dump-config | save -f ~/.config/zellij/config_orginal.kdl
zellij
ls
echo
tree
zellij
cd Music
std dir prev
use st
use std
std dir prev
std dir
man std dir
help std 
std dirs 
std dirs next
std dirs prev
cd ..
std dirs next
e
thi
tree
zellij
ls
zellij
ls
tree
killall -q polybar
startup 
polybar_launcher 
for monitor in ( xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1 ) {<\n>    $"MONITOR=($monitor) polybar --reload main -c ~/.config/polybar/config.ini &" | bash # workaround using bash, to launch bars as subprocesses. (nushell does not support background processes yet...)<\n>}
while true {<\n>    pgrep polybar<\n>    if $env.LAST_EXIT_CODE == 1 { sleep 1sec } else { break }<\n>}
    pgrep polybar
man null
help null
help nothing
    pgrep polybar
    if $env.LAST_EXIT_CODE == 1 { sleep 1sec } else { break }
    pgrep polybar
    if $env.LAST_EXIT_CODE == 1 { sleep 1sec } else { break }
killall -q polybar
while true {<\n>    pgrep polybar<\n>    if $env.LAST_EXIT_CODE == 0 { sleep 1sec } else { break }<\n>}
for monitor in ( xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1 ) {print $monitor}<\n>
polybar_launcher 
polybar
nm-applet
nm-applet
network-manager
nmcli 
che
che err> /dev/null
che err+out> /dev/null
while ((pgrep polybar | complete | get exit_code ) == 0) { sleep 1sec }
killall -q polybar
try { killall -q polybar }
try { killall -q polybar } catch {pass}
try { killall -q polybar } catch {echo 'f'}
try { killall -q polybar } 
killall -q polybar err> /dev/null
killall -q polybar err+out> /dev/null
polybar_launcher 
$ zellij setup --dump-layout default > /tmp/my-quickstart-layout-file.kdl
$ zellij setup --dump-layout default | save zellij.kdl
zellij setup --dump-layout default | save zellij.kdl
lf
htop --tree
man htop 
htop
zellij --layout v_split.kdl
zellij --layout ~/.config/zellij/v_split.kdl
zellij --layout ~/.config/zellij/v_splits.kdl
zellij --layout ~/.config/zellij/layout.kdl
ls
zellij 
zellij setup --dump-config | save -f ~/.config/zellij/config_orginal.kdl
zellij
zellij --layout compact
zellij --layout default
zellij --layout ~/.config/zellij/layout.kdl
ls
echo 
zellij --layout ~/.config/zellij/layout.kdl
zellij 
zellij --layout ~/.config/zellij/layout.kdl
man zellij --layout ~/.config/zellij/layout.kdl
man zellij --layout ~/.config/zellij/custom_layout.kdl
zellij --layout ~/.config/zellij/custom_layout.kdl
snahtoeu
zellij
zellij --layout ~/.config/zellij/custom_layout.kdl
zellij
zellij --layout ~/.config/zellij/custom_layout.kdl
zellij
zellij --options 
zellij --help
zellij options 
zellij options theme
zellij options -h
zellij options --theme
zellij options --theme solarized
zellij 
tree
tree
exa --long
exa --long --all
ls
man zellij
zellij -h
zellij list-sessions
zellij kill-all-sessions
zellij list-sessions
zellij setup
zellij list-sessions
zellij kill-all-sessions
zellij list-sessions
zellij zellij list-sessions
zellij list-sessions
zellij list-sessions | tabel
zellij list-sessions | table
zellij list-sessions | into table
zellij list-sessions | into
zellij list-sessions | split 
zellij list-sessions | split row 
zellij list-sessions | split row ' ' 
zellij list-sessions | split row '\n' 
zellij list-sessions | split column '\n' 
zellij list-sessions | split column ' ' 
zellij list-sessions 
zellij list-sessions | split words
zellij list-sessions | split rows ' '
zellij list-sessions | split row ' '
zellij list-sessions | split words --grapheme-clusters 
zellij list-sessions | split list 
zellij list-sessions | split chars 
zellij list-sessions | lines
zellij list-sessions | lines 
zellij list-sessions | lines | str contains 'rich-noisees'
zellij list-sessions | lines | str contains 'rich-noise'
zellij list-sessions | lines | str contains 'rich-noise' | reduce {|i| i == true}
zellij list-sessions | lines | str contains 'rich-noise' | reduce {|i| $i == true}
man reduce
help reduce
zellij list-sessions | lines | str contains 'rich-noise'
zellij list-sessions | lines | str contains 'rich-noise' |into bool
zellij list-sessions | lines | any { |i| $i  == true }
zellij list-sessions | lines | any { |i| $i  =~ 'rich' }
exe ( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse )
man zellij 
zellij --help
zellij attach --help
zellij run -h
zellij -s f run ls
zellij run ls 
zellij run -s f ls 
zellij run -s f -- ls 
zellij run -- ls 
zellij f run -- ls 
zellij -s f run -- ls 
zellij -s f run  ls 
zellij -s f run ls 
zellij -s f run -- ls 
zellij -s f
ls
zellij -s f run -- ls 
man zellij action 
zellij list-sessions | lines
zellij list-sessions | lines | any { |i| $i  =~ 'f' }
zellij -s f
zellij action write-chars "ls" ENTER
zellij action write-chars "ls"
zellij -s f action write-chars "ls"
ls
zellij -s f action write-chars "ls\n"
zellij -s f action write-chars "ls"
zellij -s f action write-chars "\n"
ls
focus tui htop htop
 zellij list-sessions | lines | any { |i| $i =~ htop }<\n>
 if not (zellij list-sessions | lines | any { |i| $i =~ htop }) {<\n>zellij -s htop }
focus tui htop htop
ls
xprop
ls
xprop
zellij list-sessions
focus tui htop htop
zellij list-sessions
focus tui htop htop
zellij list-sessions
zellij kill-all-sessions
zellij list-sessions
focus tui htop htop
zellij -l
zellij -l compact
wmctrl -xa htop | complete | get exit_code | into bool
wmctrl -xa htop | complete 
wmctrl -xa htop 
wmctrl -xa htop | complete | get exit_code | into bool
not ( wmctrl -xa htop | complete | get exit_code | into bool )
 ( wmctrl -xa htop | complete | get exit_code | into bool )
 zellij list-sessions | lines | any { |i| $i =~ htop }
if ( zellij list-sessions | lines | any { |i| $i =~ htop } ) {print f}
<\n> zellij list-sessions | lines | any { |i| $i =~ htop }
 zellij list-sessions | lines | any { |i| $i =~ htop }
 zellij list-sessions | lines | any { |i| $i =~ htop } | lines
if not ( zellij list-sessions | lines | any { |i| $i =~ htop } ) {print f}
zellij -s htop
alacritty msg 'hello'=<\n>
alacritty msg -h
zellij --create
zellij list-sessions
alacritty -e zellij -s htop run write-char 'htop'
alacritty -e 'zellij -s htop run write-char htop'
alacritty -e zellij -s htop
focus tui htop htop
zellij list-sessions
zezellij list-sessions
zellij list-sessions
focus tui htop htop
htop
zellij -s htop action write-chars htop
zellij -s htop action write-chars 'htop'
htop
 | less
hopt
zellij -s htop action wirzellij -s htop action write-chars 'htop'
zellij -s htop action write-chars 'htop'
htop
let command = htop
zellij -s htop action write-chars $"\'($command)\'"
zellij list-sessions
htop
zellij -s htop action write-chars $"\'($command)\'"
zellij -s htop action write-chars htop
                notify-send 'done'
zellij kzellij kill-all-sessions
htop
startup
nvime
remaps
xcape
remaps
startup
ls
man zellij
zellij -h
duration
help duration
sleep 100ms
sleep 1000ms
this
nvim
 e
e
lf
zellij -l ~/.config/zellij/custom_layout.kdl -s nvim
remaps
lf
zellij -l ~/.config/zellij/custom_layout.kdl -s nvim
ls
tree
 man zellij
cd ~
ls
cp layout.kdl leader_layout.kdl
ls
e
zellij -l ~/.config/zellij/editor_layout.kdl -s nvim
focus tui editor nvim
let name = nvim
$name == 'nvim'
$name == 'ovim'
$name == 'nvi'
focus tui editor nvim
focus tui terminal
focus tui terminal ''
focus tui terminal ' '
focus tui terminal ' '
e
nvim
e
 ls
exti
ls
this
nvim
 e
clear
man alacritty 
e
ls
clear
ping goog
while true { print 'f' }
mut c = 0; while true { c += 1 }; print $c
mut c = 0; while true { $c += 1 }; print $c
startup
focus gui Obsidian obsidian
zellij -l ~/.config/zellij/leader_layout.kdl -s nvim
e
zellij -l ~/.config/zellij/leader_layout.kdl -s nvim
e
man zellij
zellij -l ~/.config/zellij/leader_layout.kdl -s nvim
zellij -l ~/.config/zellij/leader_layout.kdl -s vim
zellij -l ~/.config/zellij/leader_layout.kdl -s im
ls
this 
sudo pacman -Rs kitty tmux fish
sudo pacman -Rs kitty tmux fisher
sudo pacman -Rs kitty tmux fish
sudo pacman -Rs fish
nvim
e
lf
man file
lf
ls
echo hello
ps
this 
ls
e
eaoeu
ls
aeou
che
ls
ps
ls
eaoeu
ls great
ls
che o
echo hello
starship -h
starship explain
starship print-config
starship -h
starship prompt
starship config
starship module
starship preset
starship preset -h
starship preset -l
starship preset pure
starship preset pure-preset
starship -h
starship config sh
starship config -h
man starship
starship --help
starship config
starship explain -h
lf
remaps
ls
lf
ls
cd ..
cd ../..
cd ..
cd ~
ls
cd Code
ls
cd rust/
ls
cd testing/
ls
 startup
$env.PATH
help merge
$env.config
zellij setup --dump-config | save zellij.kdl
bat zellij.kdl
cd Music/
std dirs prev 
ls
lsblk
ls
lsblk
lsblk |table
lsblk | split row
lsblk | split row ' '
lsblk | split row '\n'
lsblk lines
lsblk | lines
lsblk | lines | split column ' '
lsblk | lines | split words
man split
help split
lsblk | lines |table
lsblk | parse 
lsblk | parse ' '
lsblk |lines | parse ' '
lsblk |lines 
lsblk | rows 
lsblk | table 
lsblk | lines |table 
cd Music/
nvim
lsblk
print ass
print asswhole
help open
help edit 
edit
man edit
timer check
timer -v check
while true {timer check; sleep 1sec; }
while true {timer check; print ""; sleep 1sec; }
 tree
tree =
tree 
tree /
timer -tv start timer 1hr
timer -tqv start timer 1hr
man cargo
( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse )
testing
cd testing/
ls
e
( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse )
man cargo 
cargo run ( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse )
cargo build ( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse )
cargo build
cargo run
cargo run -h
cargo run -q
man String
help String
help str
( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse )
ls
ls -la
alacritty -h
alacritty --class ed, ed
alacritty --class ed ed
alacritty --class ed,ed
alacritty --title ed
lf
lf -h
man lf
help lf 
lf -h
    lf -last-dir-path '/tmp/lfcd.tmp'
bat /tmp/lfcd.tmp
pwd
pwd -h
pwd --help
help pwd
help cwd
 ls ~/.config/nushell/scripts
( ls ~/.config/nushell/scripts | get name )
( ls ~/.config/nushell/scripts | get name | path basename )
( ls ~/.config/nushell/scripts | get name | path basename | str trim '.nu')
$env.CWD
remaps
$env.PWD
$env.PWD = /
cd ~
lfcd
ls
nu
fish
nu
nu
~/.cache | path exists
'~/.cache' | path exists
 rempas
remaps
help length
count
wc
lf
lfcd
nu
bash
tree
polybar_launcher
$env.PWD
$env.PWD = /
man lf 
lf -h
cd 
lfcd
nu
nu
lfcd
cd ..
lfcd
nh
lfcd
cd ~
keybindings list 
ls
ls | less
ls |nvim
ls |nvim | less
nu
nu
nu
nu
nu
nu
nu
nu
ls
ls | less
tree
tree | less
fzf -h
bat -h
( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse --preview='bat --color -P' )
( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse --preview='bat ' )
fzf
fzf -h
lf
cd ..
cd Code
use std 
std dirs -h
std dirs 
std dirs next
std dirs prev
cd Code
std dirs prev
std dirs next
help std
help std dirs
nu
nu
nu
 tree
nvim
tree
tree | less
tree
tree | less
tree | less | less
keybindings listen 
keybindings listen
keybindings listen 
tree
keybindings listen 
ls  --help | less
ls  --help 
ls  -h
ls  -h | less
ls  -h | bat
bat  --help | less
rm  --help | less
rm  --help | bat --paging always
rm --help | bat
exa  --help | bat
fd  --help | bat
man tree
man fd
man exa
bat --help | bat
bat  --help | bat
$env.MANPAGER
e
man tree
tree --help | bat
ls  -h | bat | bat
ls  --help | bat
tree  --help | bat
tree  --help | bat -P
tree  -h | bat -P
exa -h
exa --help
exa --help | bat
man exa 
e
man i3
man  --help | bat
man  --pager='less' i3
man i3
ring  --help | bat
sound --help | bat
startup
nmtui 
nmtui
ls
lsblk
exe ( fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse )
nvim
startup
help str
help str replace
help open
ls
sudo pacman -Rs rm exa
sudo pacman -Rs exa
ls --long --header
helpls --long 
help ls
ls  --help | bat
cd .config/
ls
ls | bat
ls | bat | bat
ls  --help | bat
ls  -du
ls  -d
ls  --help | bat
save --help | bat
do  --help | bat
cd ..
touch test.txx
touch test.txt
rm test.txx
open --help | bat
open test.txt
open test.txt | echo
save  --help | bat
str --help | bat
'hello there luke' | save -a test.txt
open test.txt
open test.txt 
str replace  --help | bat
open test.txt | str replace 'luke' 'anakin' | save test.txt
open test.txt | str replace 'luke' 'anakin' | save -f test.txt
open test.txt 
open test.txt | str replace  'anakin'  'luke'| save -f test.txt
open test.txt
lf
cd ..
std dirs next
lf
man zathura 
lf
 --help | bat
lf
rg 'mode'
rg 'mode' | bat
bat  --help | bat
rg 'mode' | bat -f
rg 'mode' | less
rg 'mode' | bat -f
e
e
nu
nu
nu
nu
nu
nu
nu
nu
rg '#708183' 
rg --help | bat
rg -i '#708183' | table
parse --help | bat
parse --help
bat --help
rg -h
rg -i '#708183' | table
parse  --help
rg -i '#708183' | parse
rg -i '#708183' | parse "{} {}"
rg -i '#708183' | lines | parse "{} {}"
rg -i '#708183' | lines 
rg -i '#708183' | parse "{a} {b} .*" 
rg -i '#708183' | table
rg -i '#708183' | list
rg -i '#708183' 
let rofi_config = '~/.config/rofi/theme.rasi'<\n>open $rofi_config
let rofi_config = '~/.config/rofi/theme.rasi'<\n>open $rofi_config | head 
head  --help
first  --help
let rofi_config = '~/.config/rofi/theme.rasi'<\n>open $rofi_config | first 20
let rofi_config = '~/.config/rofi/theme.rasi'<\n>open $rofi_config | head 
head  --help
let rofi_config = '~/.config/rofi/theme.rasi'<\n>open $rofi_config | head -n 20
let rofi_config = '~/.config/rofi/theme.rasi'<\n>open $rofi_config | head -n 50
fish
yay solarized
yay -S gtk3-theme-numix-solarized
remaps 
sudo pacman -Syu
let vimcfg = '~/.config/nvim/lua/user/colorscheme.lua'<\n>open $vimcfg | str replace 'dark' 'light' | save -f $vimcfg
let vimcfg = '~/.config/nvim/lua/user/colorscheme.lua'<\n>open $vimcfg | str replace 'dark' 'light' 
$vimcfg
ls $vimcfg
$vimcfg | path exists
open $vimcfg | str replace 'dark' 'light' | save $vimcfg
open test.txt
open test.txt | str replace  'anakin'  'luke'| save -f test.txt
open test.txt | str replace  'anakin'  'luke'| save -f test.txt; open test.txt
open test.txt | str replace  'luke'  'ana'| save -f test.txt; open test.txt
open test.txt | str replace  'ana'  'luke'| save -f test.txt; open test.txt
open test.txt | str replace  'luke'  'ana'| save -f test.txt; open test.txt
save  --help
path  --help
$vimcfg | path expand 
let vim_cfg = '~/.config/nvim/lua/user/colorscheme.lua'<\n>open $vim_cfg | str replace 'dark' 'light' | save -f ( $vim_cfg | path expand )
e
let vim_cfg = '~/.config/nvim/lua/user/colorscheme.lua'<\n>open $vim_cfg | str replace 'light' 'dark' | save -f ( $vim_cfg | path expand )
let nu_cfg = '~/.config/nushell/config.nu'<\n>open $nu_cfg | str replace 'solarized_dark ' 'solarized_light '
let nu_cfg = '~/.config/nushell/config.nu'<\n>open $nu_cfg | str replace 'solarized_dark ' 'solarized_light ' | save -f ( $nu_cfg | path expand ) # the whitespace after is important
open $nu_cfg
ls
ls -lsblk
this 
let zathurarc_light = '~/.config/zathura/zathurarc_solarized_light'<\n>let zathurarc = '~/.config/zathura/zathurarc'<\n>open $zathura_light | save -f ( $zathurarc | path expand )
let zathurarc_light = '~/.config/zathura/zathurarc_solarized_light'<\n>let zathurarc = '~/.config/zathura/zathurarc'<\n>open $zathurarc_light | save -f ( $zathurarc | path expand )
open $zathurarc
let polybar_light_cfg = '~/.config/polybar/config_solarized_light.ini'<\n>polybar_launcher $polybar_light_cfg
\poly
        let polybar_light_cfg = '~/.config/polybar/config_solarized_light.ini'<\n>        polybar_launcher $polybar_light_cfg<\n>
timer
timer check
timer start timer
timer start timer 1hr
timer start timer
timer start timer 1hr
timer stop
timer
timer  --help
timer start timer
exit  --help
timer start interval 5hr
timer start interval 5hr 2min
timer stop
timer start interval 5hr 2min
timer stop
let rofi_cfg = '~/.config/rofi/config.rasi'<\n>open $rofi_cfg | str replace 'solarized_dark' 'solarized_light' | save -f ( $rofi_cfg | path expand )
        let rofi_cfg = '~/.config/rofi/config.rasi'        ;open $rofi_cfg | str replace 'solarized_dark' 'solarized_light' | save -f ( $rofi_cfg | path expand )
let alacritty_cfg = '~/.config/alacritty/alacritty.yml'<\n>open $alacritty_cfg | str replace 'solarized_dark' 'solarized_light' | save -f ( $alacritty_cfg | path expand )
        let alacritty_cfg = '~/.config/alacritty/alacritty.yml'
<\n>        let alacritty_cfg = '~/.config/alacritty/alacritty.yml'<\n>        open $alacritty_cfg | str replace 'solarized_dark' 'solarized_light' | save -f ( $alacritty_cfg | path expand )
open $alacritty_cfg
open $alacritty_cfg | str join
str replace  --help
open -h
open -r $alacritty_cfg 
open $alacritty_cfg 
open $alacritty_cfg | get import
open $alacritty_cfg | get import | str replace 'dark' 'light'
<\n>        let alacritty_cfg = '~/.config/alacritty/alacritty.yml'<\n>        open -r $alacritty_cfg | str replace 'solarized_dark' 'solarized_light' | save -f ( $alacritty_cfg | path expand )
<\n>        let alacritty_cfg = '~/.config/alacritty/alacritty.yml'<\n>        open -r $alacritty_cfg | str replace 'solarized_light' 'solarized_dark' | save -f ( $alacritty_cfg | path expand )
<\n>        let gtk_cfg = '~/.config/gtk-3.0/settings.ini'<\n>        open -r $gtk_cfg | str replace 'Solarized-Light' 'Solarized-Dark' | save -f ( $gtk_cfg | path expand )
<\n>        let gtk_cfg = '~/.config/gtk-3.0/settings.ini'<\n>        open -r $gtk_cfg | str replace 'Solarized-Dark' 'Solarized-Light' | save -f ( $gtk_cfg | path expand )
lf
extract Breeze-Solarized-Light.tar.tar
ls
yay solarized light
yay solarized gtk
lf
rg '#002b36'
let i3_cfg = '~/.config/i3/config'<\n>open -r $i3_cfg | str replace 'solarized_dark' 'solarized_light' | save -f ( $i3_cfg | path expand )
bgswitch --light
bgswitch 
bgswitch -h
i3  --help
i3-msg restart
wmctrl  --help
nvim
~/.config/scripts/bgswitch --dark
~/.config/scripts/bgswitch --light
i3-msg exec "~/.config/scripts/bgswitch --dark"
i3-msg exec "~/.config/scripts/bgswitch --dark & "
i3-msg exec "~/.config/scripts/bgswitch --dark | bash"
bgswitch -h
bgswitch --light
bgswitch --dark
e
bgswitch --light
nvim
ls
git status
git add i3
git add i3 alacritty nushell nvim polybar rofi starship.toml scripts zellij zathura
gc 
git commit 
git status
git add themes
git commit  --help
git commit --help
git commit -m 'sync'
git push
keepassxc  --help
bgswitch --dark
bgswitch --light
alacritty -e bgswitch --light
bgswitch -h
lsblk
fdisk -l
yay usb
yay unetbooting
yay unetbootin
unetbootin
yay -Rs unetbootin
sudo fdisk -l
lsblk -f
sudo fdisk -l
yay gparted
gparted
sudo gpardet
sudo gpartet
sudo gparted
sudo fdisk -l
remaps 
startup
bgswitch -l
sudo fdisk -l
sudo gparted=
sudo mount /dev/sda
sudo gparted
sudo umount /dev/sda
sudo umount /dev/sdasudo fdisk -l
sudo fdisk -l
ls
^ls
sudo dd bs=4M if=~/Downloads/EndeavourOS_Cassini_Nova-03-2023_R1.iso of=/dev/sda conv=fsync oflag=direct status=progress
sudo dd bs=4M if='~/Downloads/EndeavourOS_Cassini_Nova-03-2023_R1.iso' of=/dev/sda conv=fsync oflag=direct status=progress
sudo dd bs=4M if=EndeavourOS_Cassini_Nova-03-2023_R1.iso of=/dev/sda conv=fsync oflag=direct status=progress
yay popsicle
yay popsicle-bin
sudo popsicle
sudo popsicle-gtk
sudo popsicle
popsicle-gkt
popsicle-gtk
sudo popsicle-gtk
popsicle-gtk -h
yay gnome disk
sudo gparted
sudo gnome-disks 
sudo umount /dev/sda
sudo mkfs.ext4 /dev/sda
sudo fdisk -l
sudo mkfs.ext4 /dev/sda1
sudo umount /dev/sda1
sudo mkfs.ext4 /dev/sda1
sudo umount /dev/sda1
sudo mkfs.fat32 /dev/sda1
mkfs
mkfs  --help
man mkfs
man mkfs.vfat
sudo fdisk -l
sudo umount /dev/sda1
lsblk
man dd
sudo dd bs=4M if=EndeavourOS_Cassini_Nova-03-2023_R1.iso of=/dev/sda1 conv=fsync oflag=direct status=progress
 startup
lf
~
nvim
sudo gnome-disks 
random  --help
spotdl
yay spotdl
spotdl
yay -Rs spotdl
yay -Rs python-spotdl
yay spot
pulsemixer
focus tui pulsemixer pulsemixer
yay -S spotify-dl-git
ls
yay -Rs spotify-dl-git
bgswitch -d
bgswitch -l
bgswitch -d
bgswitch -l
bgswitch -d
bgswitch -l
focus tui pulsemixer pulsemixer
this is prot
time start
timer start
timer start interval
ls
lsblk
ps
bgswitch -d
 startup
bgswitch -d
startup
bgswitch -d
bgswitch -l
bgswitch -d
ls
git status
git add lf
git status
git commit -ma 'sync'; git push
git commit -ma 'sync'
git commit -ma 
git commit -maon
git push
mkdir --help
cd ..
md testing
cd ..
rmdir  --help
rmdir testing/
ls
    let handlers = [ [extension command];<\n>                   ['tar\.bz2|tbz|tbz2' 'tar xvjf']<\n>                   ['tar\.gz|tgz'       'tar xvzf']<\n>                   ['tar\.xz|txz'       'tar xvf']<\n>                   ['tar\.Z'            'tar xvZf']<\n>                   ['bz2'               'bunzip2']<\n>                   ['deb'               'ar x']<\n>                   ['gz'                'gunzip']<\n>                   ['pkg'               'pkgutil --expand']<\n>                   ['rar'               'unrar x']<\n>                   ['tar'               'tar xvf']<\n>                   ['xz'                'xz --decompress']<\n>                   ['zip|war|jar|nupkg' 'unzip']<\n>                   ['Z'                 'uncompress']<\n>                   ['7z'                '7za x']<\n>                 ]<\n>
$handlers
where $it == tar
$handlers | where $it == tar
$handlers | where $it =~ tar
$handlers | where $it =~ 'tar'
$handlers | get command |where $it =~ 'tar'
$handlers | get command | where $it =~ 'tar'
$handlers | get command | any $it =~ 'tar'
$handlers | get command | any {$it =~ 'tar'}
$handlers | get command | any {|it| $it =~ 'tar'}
$handlers | get command | where {|it| $it =~ 'tar' }
bgswitch -l
sudo blueman
sudo blueberroy
sudo blueberry
remaps
e
nvim
ls
remaps
sudo systemctl enable bluetooth
sudo systemctl start bluetooth
sudo systemctl start dbus
yay -S bluez bluez-utils-compat blueman; yay -Rs blueberry
sudo pacman -Ss bluez
sudo pacman -S bluez-tools 
nu
 startup
blueberry
sudo pacman -Rs blueberry
blueman
bluez
bluez-
bluemoon 
blueman-manager 
sudo pacman -Ss blueman
ls
fd
fd | lines
fd 
each  --help
fd | each {|| str snake-case }
fd | lines |each {|| str snake-case }
ls
mv --help
fd | lines | each { |i| mv $i ( $i | str snake-case ) }
fd | lines | each { |i| do -i { mv $i ( $i | str snake-case ) } }
ls
fd | lines | each { |i| ( $i | str snake-case ) }
split --help
fd | lines | each { |i| ( $i | split list '_' ) }
fd | lines | each { split list '_'  }
fd | each { split list '_'  }
fd | lines 
fd | lines | split list '_'
split list --help
'abc bcd' | split list ' '
fd | lines | each { split list '_' }
fd | lines | each { split list '\_' }
fd | lines | each { split list '_' }
fd | lines | str join | each { split list '_' }
fd | lines | each { split list '_' }
['abc bcd'] | each { split list ' ' }
fd | lines | each { split row '_' }
fd | lines | each { split words}
str join  --help
[a b c] | str join '_'
last  --help
[a b c] | range 1..-1
range --help
[a b c] | range 0..(-1)
[a b c] | range 0..(-2)
fd | lines | each { split words } | range 0..(-2) | str join '_'<\n>
fd | lines | each { split words } | range 0..(-2) <\n>
fd | lines | each { split words } | each { range 0..(-2) }<\n>
fd | lines | each { split words } | each { range 0..(-2) | str join '_' }<\n>
drop  --help
let name = fd | lines | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>}<\n>$name
let name = ( fd | lines | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})$name
let name = ( fd | lines | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>$name
skip
skip --help
last  --help
let name = ( fd | lines | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>let ext = ( fd | lines | each {<\n>    split words<\n>    | last<\n>})<\n>$name<\n>$ext
fd --help
nvim
fd  --help | bat
fd  --help | less
bat
hello | bat
'hello' | bat
bat  --help | bat
bat -h
bat --list-theme
bat --list-themes
bat -h
bat --theme solarized
'hello' |bat --theme solarized
'hello' |bat --theme Solarized
bat --list-themes
'hello' |bat --theme=Solarized
'hello' |bat --theme Solarized
'hello' |bat --theme Solarized (light)
'hello' |bat --theme gruvbok-light
'hello' |bat --theme gruvbox-light
'hello' |bat --theme solarized-dark
'hello' |bat --theme solarized
'hello' |bat --theme solarized (dark)
'hello' |bat --theme 'Solarized (dark)'
'hello' | bat --theme 'Solarized (dark)'
fd  --help | bat
fd  --help | bat --theme 'Solarized (dark)'
fd . 
fd . | bat
fd . | less
bat  --help | bat --theme 'Solarized (dark)'
bat  --help | bat --theme 'Solarized (dark)' -f
fd . | bat -f
fd . 
e
let name = ( fd -tf | lines | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>$name<\n>$ext
let name = ( fd -tf | lines | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>$name
let name = ( fd -tf | lines | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>$name<\n>$ext
let name = ( fd -tf | lines | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>print $name $ext<\n>
fd  --help | bat --theme 'Solarized (dark)'
zip --help | bat --theme 'Solarized (dark)'
ls | bat
enumerate --help | bat --theme 'Solarized (dark)'
values --help | bat --theme 'Solarized (dark)'
columns --help | bat --theme 'Solarized (dark)'
[a b c] | columns
[a b c] | enumerate
[a b c] | enumerate | get 0
[a b c] | enumerate | get inedx
[a b c] | enumerate | get index
zip  --help | bat --theme 'Solarized (dark)'
let name = ( fd -tf | lines | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>$name | zip $ext
let name = ( fd -tf | lines | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>$name | zip $ext | each { str join '.' }
let name = ( fd -tf | lines | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>$name | zip $ext | each { str join '.' }<\n>let files = ( fd -tf )<\n>$files
let name = ( $files | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>$name | zip $ext | each { str join '.' }<\n>let files = ( fd -tf | lines )<\n>$files
let name = ( $files | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>let files = ( fd -tf | lines )<\n>print $files $converted
let name = ( $files | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>let files = ( fd -tf | lines )<\n>print $name $converted
let name = ( $files | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>    | each { |i|<\n>        if ($i | lenght ) > 1 {<\n>            skip 1<\n>            }<\n>        }<\n>    )<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>let files = ( fd -tf | lines )<\n>print $name $converted
length  --help | bat --theme 'Solarized (dark)'
str  --help | bat --theme 'Solarized (dark)'
let name = ( $files | each {<\n>    split words<\n>    | drop 1<\n>    | each {|i| <\n>        if ( $i | length ) > 1 {<\n>            skip 1<\n>        }<\n>    }<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>let files = ( fd -tf | lines )<\n>print $name $converted
let name = ( $files | each {<\n>    split words<\n>    | drop 1<\n>    | each {|it| if ( $it | length ) > 1 { skip 1 }}<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>let files = ( fd -tf | lines )<\n>print $name $converted
let name = ( $files | each {<\n>    split words<\n>    | drop 1<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>let files = ( fd -tf | lines )<\n>print $name $converted
let files = ( fd -tf | lines )<\n>let name = ( $files | each {<\n>    split words<\n>    | drop 1<\n>    | each {|it| if ( $it | length ) > 1 { skip 1 }}<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $converted
fd -tf
fd -tf | lines
ls  --help | bat --theme 'Solarized (dark)'
let files = ( fd -tf | lines )<\n>let name = ( $files | each {<\n>    split words<\n>    | drop 1<\n>    | each {|it| if ( $it | length ) > 1 { skip 1 }}<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $converted
let files = ( fd -tf | lines )<\n>let name = ( $files | each { |i|<\n>    split words<\n>    | drop 1<\n>    | if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $converted
let files = ( fd -tf | lines )
$files
let files = ( fd -tf | lines )<\n>let name = ( $files | each { |i|<\n>    split words<\n>    | drop 1<\n>    | if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>})<\n># let ext = ( $files | each {<\n>#     split words<\n>#     | last<\n># })<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $converted
let files = ( fd -tf | lines )<\n>let name = ( $files | each { |i|<\n>    split words<\n>    | drop 1<\n>    | if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $converted
let files = ( fd -tf | lines )<\n>let name = ( $files | each { |i|<\n>    split words<\n>    | drop 1<\n>    | if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name
let files = ( fd -tf | lines )<\n>let name = ( $files | each { |i|<\n>    split words<\n>    | drop 1<\n>    | if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name
let files = ( fd -tf | lines )<\n>let name = ( $files | each { |i|<\n>    split words<\n>    | drop 1<\n>    | if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>$name
let name = ( fd -tf | lines | each { |i|<\n>    split words<\n>    | drop 1<\n>    | if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )
let name = ( fd -tf | lines | each { |i|<\n>    split words<\n>    | drop 1<\n>    | if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $converted
let files = ( fd -tf | lines )<\n>print $files
let name = ( fd -tf | lines | each { |i|<\n>    split words<\n>    | drop 1<\n>    | if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>$converted
let name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words; drop 1; if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>$ext
let name = ( fd -tf <\n>    | lines <\n>    # | each { |i| split words | drop 1 | if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>})<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 } #| if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>)<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 } #| if ( $i | length ) > 1 { skip 1 }<\n>    | str join '_'<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    # | each { |i| split words | drop 1 } #| if ( $i | length ) > 1 { skip 1 }<\n>    # | str join '_'<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { split words | drop 1 } #| if ( $i | length ) > 1 { skip 1 }<\n>    # | str join '_'<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { split words | drop 1 | str join '_' } #| if ( $i | length ) > 1 { skip 1 }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { split words | drop 1 | if ( $i | length ) > 1 { skip 1 } | str join '_' }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 | if ( $i | length ) > 1 { skip 1 } | str join '_' }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 | str join '_' }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
mut name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 }<\n>    )<\n>name = ( $name | each { |i| if ( $i | length ) > 1 { skip 1 }} )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
mut name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 }<\n>    )<\n>name = ( $name | each { |i| if ( $i | length ) > 1 { $i | skip 1 }} )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
mut name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 }<\n>    )<\n>$name<\n>name = ( $name | each { |i| if ( $i | length ) > 1 { $i | skip 1 }} )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
mut name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 }<\n>    )<\n>$name<\n># name = ( $name | each { |i| if ( $i | length ) > 1 { $i | skip 1 }} )<\n># let ext = ( fd -tf | lines | each {<\n>#     split words<\n>#     | last<\n># })<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 }<\n>    )<\n>$name<\n># let ext = ( fd -tf | lines | each {<\n>#     split words<\n>#     | last<\n># })<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 }<\n>    | each { || length}<\n>    )<\n>$name<\n># let ext = ( fd -tf | lines | each {<\n>#     split words<\n>#     | last<\n># })<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext
[a b c] | if length > 1 { print 'a'}
[a b c] | if (length) > 1 { print 'a'}
[a b c] | if ($in |length) > 1 { print 'a'}
let name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 }<\n>    | each { if ( $in | length ) > 1 { $in | skip 1 }}<\n>    )<\n>$name<\n># let ext = ( fd -tf | lines | each {<\n>#     split words<\n>#     | last<\n># })<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 }<\n>    # | each { if ( $in | length ) > 1 { $in | skip 1 }}<\n>    )<\n>$name<\n># let ext = ( fd -tf | lines | each {<\n>#     split words<\n>#     | last<\n># })<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 }<\n>    | each { if ( $in | length ) > 1 { $in | skip 1 }}<\n>    )<\n>$name<\n># let ext = ( fd -tf | lines | each {<\n>#     split words<\n>#     | last<\n># })<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { split words | drop 1 | if ( $in | length ) > 1 { $in | skip 1 }}<\n>    )<\n>$name<\n># let ext = ( fd -tf | lines | each {<\n>#     split words<\n>#     | last<\n># })<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { |i| split words | drop 1 | if ( $i | length ) > 1 { $i | skip 1 }}<\n>    )<\n>$name<\n># let ext = ( fd -tf | lines | each {<\n>#     split words<\n>#     | last<\n># })<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { split words | drop 1 | if ( $in | length ) > 1 { $in | skip 1 }}<\n>    )<\n>$name<\n># let ext = ( fd -tf | lines | each {<\n>#     split words<\n>#     | last<\n># })<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext
keybindings list
let name = ( fd -tf <\n>    | lines <\n>    | each { split words | drop 1 | if ( $in | length ) > 1 { $in | skip 1 }}<\n>    )<\n>$name<\n># let ext = ( fd -tf | lines | each {<\n>#     split words<\n>#     | last<\n># })<\n># let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { split words | drop 1 | if ( $in | length ) > 1 { $in | skip 1 }}<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { split words | drop 1 | if ( $in | length ) > 1 { $in | skip 1 }}<\n>    | str join '_'<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in <\n>        | length ) > 1 { $in | skip 1 }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in <\n>        | length ) > 1 { $in | skip 1 }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext $converted | bat
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in <\n>        | length ) > 1 { $in | skip 1 }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>echo $name $ext $converted | bat
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in <\n>        | length ) > 1 { $in | skip 1 }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext $converted
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        # | if ( $in | length ) > 1 { $in | skip 1 }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext $converted
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 1 { $in | skip 1 }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext $converted
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext $converted
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | skip 1<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext $converted
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        # | skip 1<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext $converted
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext $converted
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { 'f' }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext $converted
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { 'f' }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext $converted<\n>print $name
skip --help | bat --theme 'Solarized (dark)'
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in }<\n>        # | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext $converted<\n>print $name
skip --help | bat --theme 'Solarized (dark)'
[a b c] | if ($in |length) > 1 { $in | skip 1}
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 }<\n>        # | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext $converted<\n>print $name
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        # | if ( $in | length ) > 2 { $in | skip 1 }<\n>        # | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext $converted<\n>print $name
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext $converted<\n>print $name
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n># print $name $ext $converted<\n>print $name
let name = ( fd -tf <\n>    | lines <\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( fd -tf | lines | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print $name $ext $converted
let files = ( ft -tf | lines )<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>$converted
let files = ( fd -tf | lines )<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>$converted
let files = ( fd -tf | lines )<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>$files | zip $converted
let files = ( fd -tf | lines )<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    mv -v $i.0 $i.1<\n>}
let files = ( fd -tf | lines )<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    print $i.0 $i.1<\n>}
let files = ( fd -tf | lines )<\n>let folder = ( $files | lines | split words | get 0) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    # print $i.0 $i.1<\n>}<\n>$folder
let files = ( fd -tf | lines )<\n>let folder = ( $files | split words | get 0) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    # print $i.0 $i.1<\n>}<\n>$folder
let files = ( fd -tf | lines )<\n>let folder = ( $files | each { split words | get 0 }) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    # print $i.0 $i.1<\n>}<\n>$folder
let files = ( fd -tf | lines )<\n>let folder = ( $files | each { split words | get 0 } | uniq ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    # print $i.0 $i.1<\n>}<\n>$folder
let files = ( fd -tf | lines )<\n>let folder = ( $files | each { split words | get 0 } | uniq ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    # print $i.0 $i.1<\n>}<\n>$folder<\n>
lf
ls
mkdir test
touch test.txt
mv test.txt test/test.txt
let files = ( fd -tf | lines )<\n>let folders = ( $files | each { split words | get 0 } | uniq ) <\n>for each folder in $folders {<\n>    if not ( $folder | path exists )<\n>        print $folder<\n>        # mkdir $folder<\n>    }<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $folder | zip $name | each { str join } | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    print $"($i.0) -> ($i.1)"<\n>}<\n>$converted
let files = ( fd -tf | lines )<\n>let folders = ( $files | each { split words | get 0 } | uniq ) <\n>for each folder in $folders {<\n>    if not ( $folder | path exists ) {<\n>        print $folder<\n>        # mkdir $folder<\n>    }<\n>}<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $folder | zip $name | each { str join } | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    print $"($i.0) -> ($i.1)"<\n>}<\n>$converted
let files = ( fd -tf | lines )<\n>let folders = ( $files | each { split words | get 0 } | uniq ) <\n>for folder in $folders {<\n>    if not ( $folder | path exists ) {<\n>        print $folder<\n>        # mkdir $folder<\n>    }<\n>}<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $folder | zip $name | each { str join } | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    print $"($i.0) -> ($i.1)"<\n>}<\n>$converted
let files = ( fd -tf | lines )<\n>let folders = ( $files | each { split words | get 0 } | uniq ) <\n>for folder in $folders {<\n>    if not ( $folder | path exists ) {<\n>        print $folder<\n>        # mkdir $folder<\n>    }<\n>}<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $folder | zip $name | each { str join '/' } | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    print $"($i.0) -> ($i.1)"<\n>}<\n>$converted
let files = ( fd -tf | lines )<\n>let folders = ( $files | each { split words | get 0 } | uniq ) <\n>for folder in $folders {<\n>    if not ( $folder | path exists ) {<\n>        print $folder<\n>        # mkdir $folder<\n>    }<\n>}<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $folder | zip $name | each { str join '/' } | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    print $"($i.0) -> ($i.1)"<\n>}<\n>print $converted
let files = ( fd -tf | lines )<\n>let folders = ( $files | each { split words | get 0 } | uniq ) <\n>for folder in $folders {<\n>    if not ( $folder | path exists ) {<\n>        print $folder<\n>        # mkdir $folder<\n>    }<\n>}<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $folder | zip $name | each { str join '/' } | zip $ext | each { str join '.' } )<\n>print $converted<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    print $"($i.0) -> ($i.1)"<\n>}
let files = ( fd -tf | lines )<\n>let folders = ( $files | each { split words | get 0 } | uniq ) <\n>for folder in $folders {<\n>    if not ( $folder | path exists ) {<\n>        print $folder<\n>        # mkdir $folder<\n>    }<\n>}<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $folder | zip $name | each { str join '/' } )<\n># | zip $ext | each { str join '.' } )<\n>print $converted<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    print $"($i.0) -> ($i.1)"<\n>}
let files = ( fd -tf | lines )<\n>let folders = ( $files | each { split words | get 0 } ) <\n>for folder in $folders {<\n>    if not ( $folder | path exists ) {<\n>        # print $folder<\n>        # mkdir $folder<\n>    }<\n>}<\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $folder | zip $name | each { str join '/' } )<\n># | zip $ext | each { str join '.' } )<\n>print $converted<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    print $"($i.0) -> ($i.1)"<\n>}
let files = ( fd -tf | lines )<\n>let folder = ( $files | each { split words | get 0 } | uniq ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>for i in ( $files | zip $converted ) {<\n>    # mv -v $i.0 $i.1<\n>    # print $i.0 $i.1<\n>}<\n>$folder<\n>
let files = ( fd -tf | lines )<\n>let folder = ( $files | each { split words | get 0 } | uniq ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>$files | zip $converted<\n># $folder
let files = ( fd -tf | lines )<\n>let folder = ( $files | each { split words | get 0 } | uniq ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>[ from: $files, to: $converted ]<\n># $folder
let files = ( fd -tf | lines )<\n>let folder = ( $files | each { split words | get 0 } | uniq ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>{ from: $files, to: $converted }<\n># $folder
let files = ( fd -tf | lines )<\n>let folder = ( $files | each { split words | get 0 } | uniq ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>{ from: $files, to: $converted }<\n>$folder
let files = ( fd -tf | lines )<\n>let folder = ( $files | each { split words | get 0 } | uniq ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>print { from: $files, to: $converted } $folder
let files = ( fd -tf | lines )<\n>let folder = ( $files | each { split words | get 0 } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( $name | zip $ext | each { str join '.' } )<\n>{ from: $files, to: $converted }
let files = ( fd -tf | lines )<\n>let folder = ( $files | each { split words | get 0 } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folder | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n>{ from: $files, to: $converted }
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | where ( $in | length ) > 1 <\n>    | each { split words | get 0 } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folder | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n>{ from: $files, to: $converted }
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | where ( $in | length ) > 2<\n>    | each { split words | get 0 } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folder | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n>{ from: $files, to: $converted }
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | where ( $in | length ) > 2<\n>    | each { split words | get 0 } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>$folders
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | where ( $in | length ) > 2<\n>    | each { split words | get 0 } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>print $files $folders
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | each { split words | where ( $in | length ) > 2 |  get 0 } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>print $files $folders
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | each { split words | where ( $in | length ) > 2 } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>print $files $folders
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | each { split words | filter ( $in | length ) > 2 } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>print $files $folders
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | each { split words | filter { ( $in | length ) > 2 } } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>print $files $folders
where --help | bat --theme 'Solarized (dark)'
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | each { split words | where ( $in | length ) > 2 } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>$folders
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | each { split words | where ( $in | length ) > 2 } | try {get 0 } ) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>$folders
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | each { split words | where ( $in | length ) > 2 | do -i {get 0} }) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>$folders
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | each { split words | where ( $in | length ) > 2 | get 0 }) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>$folders
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | each { split words | where ( $in | length ) > 2 | do -i { get 0 } }) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>$folders
pass  --help | bat --theme 'Solarized (dark)'
continue  --help | bat --theme 'Solarized (dark)'
let files = ( fd -tf | lines )<\n>let folders = ( <\n>    $files <\n>    | each { split words | where ( $in | length ) > 2 | if ( $in | length ) != 0 { get 0 } }) <\n>let name = ( $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( $files | each {<\n>    split words<\n>    | last<\n>})<\n>let converted = ( <\n>    $folders | zip (<\n>        $name | zip $ext | each { str join '.' } <\n>    ) | each { str join '/' }<\n>)<\n># { from: $files, to: $converted }<\n>$folders
let files = ( fd -tf | lines )<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $name <\n>    | zip $ext <\n>    | each { str join '.' } <\n>) <\n>{ from: $files, to: $converted }
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | each { split words | get 0 }<\n>    )<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $name <\n>    | zip $ext <\n>    | each { str join '.' } <\n>) <\n>{ from: $files, to: $converted }
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | each { split words | get 0 }<\n>    )<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $name <\n>    | zip $ext <\n>    | each { str join '.' } <\n>) <\n>$folder<\n># { from: $files, to: $converted }
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | each { split words | get 0 }<\n>    )<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $folder <\n>    | zip (<\n>        $name <\n>        | zip $ext <\n>        | each { str join '.' } <\n>    )<\n>    | each { str join }<\n>    <\n>) <\n>$converted<\n># { from: $files, to: $converted }
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | each { split words | get 0 }<\n>    )<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $folder <\n>    | zip (<\n>        $name <\n>        | zip $ext <\n>        | each { str join '.' } <\n>    )<\n>    | each { str join '/' }<\n>    <\n>) <\n>$converted<\n># { from: $files, to: $converted }
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | each { split words | get 0 }<\n>    )<\n>$folder | uniq | each { do -i { mkdir $in } }<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $folder <\n>    | zip (<\n>        $name <\n>        | zip $ext <\n>        | each { str join '.' } <\n>    )<\n>    | each { str join '/' }<\n>    <\n>) <\n>{ from: $files, to: $converted } | each { print $"($in.0) -> ($in.1)" }
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | each { split words | get 0 }<\n>    )<\n>$folder | uniq | each { do -i { mkdir $in } }<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $folder <\n>    | zip (<\n>        $name <\n>        | zip $ext <\n>        | each { str join '.' } <\n>    )<\n>    | each { str join '/' }<\n>    <\n>) <\n>{ from: $files, to: $converted }
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | each { split words | get 0 }<\n>    )<\n>$folder | uniq | each { do -i { mkdir $in } }<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $folder <\n>    | zip (<\n>        $name <\n>        | zip $ext <\n>        | each { str join '.' } <\n>    )<\n>    | each { str join '/' }<\n>    <\n>) <\n>for i in { from: $files, to: $converted } {<\n>    print $i.from<\n>}
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | each { split words | get 0 }<\n>    )<\n>$folder | uniq | each { do -i { mkdir $in } }<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $folder <\n>    | zip (<\n>        $name <\n>        | zip $ext <\n>        | each { str join '.' } <\n>    )<\n>    | each { str join '/' }<\n>    <\n>) <\n>for i in { from: $files, to: $converted } {<\n>    print $"($i.from) -> ($i.to)"<\n>}
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | each { split words | get 0 }<\n>    )<\n>$folder | uniq | each { do -i { mkdir $in } }<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $folder <\n>    | zip (<\n>        $name <\n>        | zip $ext <\n>        | each { str join '.' } <\n>    )<\n>    | each { str join '/' }<\n>    <\n>) <\n>for i in { from: $files, to: $converted } {<\n>    print $i.from $i.to<\n>}
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | each { split words | get 0 }<\n>    )<\n>$folder | uniq | each { do -i { mkdir $in } }<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $folder <\n>    | zip (<\n>        $name <\n>        | zip $ext <\n>        | each { str join '.' } <\n>    )<\n>    | each { str join '/' }<\n>    <\n>) <\n>for i in { from: $files, to: $converted } {<\n>    mv -v $i.from $i.to<\n>}
for  --help | bat --theme 'Solarized (dark)'
help for
let files = ( fd -tf | lines )<\n>let folder = ( <\n>    $files <\n>    | each { split words | get 0 }<\n>    )<\n>$folder | uniq | each { do -i { mkdir $in } }<\n>let name = ( <\n>    $files<\n>    | each { <\n>        split words <\n>        | drop 1 <\n>        | if ( $in | length ) > 2 { $in | skip 1 } else { $in }<\n>        | str join '_'<\n>        }<\n>    )<\n>let ext = ( <\n>    $files <\n>    | each { split words | last}<\n>    )<\n>let converted = ( <\n>    $folder <\n>    | zip (<\n>        $name <\n>        | zip $ext <\n>        | each { str join '.' } <\n>    )<\n>    | each { str join '/' }<\n>    <\n>) <\n><\n>{ from: $files, to: $converted } | each {<\n>    mv -v $in.from $in.to<\n>}
 startup
ls
yay Iosevka
sudo pacman -S ttf-iosevka-nerd
sudo pacman -Syu
yay i3
remaps
sudo pacman -S ttf-iosevka-nerd
sudo pacman -Syu ttf-iosevka-nerd
rg 'Iosevka' -l | lines
rg 'Iosevka' -l | lines | path expand | each {open $in | str replace 'Iosevka' 'Iosevka' | save $in}
rg 'Iosevka' -l | lines | each {open $in | str replace 'Iosevka' 'Iosevka' | save $in}
rg 'Iosevka' -l | lines | each {|i| open $i | str replace 'Iosevka' 'Iosevka' | save $i}
rg 'Iosevka' -l | lines | each {|i| open $i | str replace 'Iosevka' 'Iosevka' | save -f $i}
open  --help | bat --theme 'Solarized (dark)'
rg 'Iosevka' -l | lines | each {|i| open $i -r | str replace 'Iosevka' 'Iosevka' | save -f $i}
rg 'Iosevka'
str replace  --help | bat --theme 'Solarized (dark)'
rg 'Go Mono' -l | lines | each {|i| open $i -r | str replace -a 'Go Mono' 'Iosevka' | save -f $i}
rg 'Go Mono'
lf
startup
nvim
indent --help | bat --theme 'Solarized (dark)'
e
yay indent
git status
git add nushell
git add commands
git commit  --help | bat --theme 'Solarized (dark)'
git commit -am 'font change'
git push
timer 
timer -t start timer 60min
timer stop
timer -t stop
git status
git commit -am 'font change'
git push
bgswitch -l
startup
timer -q check
timer check
startup
timer
timer -h
timer start interval 1hr 5min
timer -t start interval 1min 5min
timer -t start interval 2min 5min
time stop
timer stop
timer -t start interval 60min 5min
timer start interval 1sec 5min
timer start interval 1min 5min
yay chromium
extract drive-download-20230523T094026Z-001.zip
ls
bat locations.json
open locations.json
open trip.json
videos
cd videos/
bat user.json
open user.json
syncthing
cd 
xrandr -h
xrandr --help | bat --theme 'Solarized (dark)'
sudo xrandr --dpi  --help | bat --theme 'Solarized (dark)'
sudo xrandr  --help | bat --theme 'Solarized (dark)'
sudo xrandr --dpi 90
ls
ls.name
ls | get name
(ls).name
ls | get name | split words 
ls | get name | split list '_'
ls | get name | each {split list '_'}
ls | get name | each {split words}
ls | get name | each {split words} | get 0
ls | get name | each {split words; get 0}
ls | get name | each {split words | get 0}
ls | get name | each {|i| mv -v $i (ls | get name | each {split words | get 0})}
ls | get name | each {|i| mv -v $i ($i | each {split words | get 0})}
fd 
fd | lines
fd | lines | each {|i| $i | split words }
pop  --help | bat --theme 'Solarized (dark)'
skip  --help | bat --theme 'Solarized (dark)'
fd | lines | each {|i| $i | split words | skip 1}
fd | lines 
fd | lines | where {|i| if ($i =~ '_')}
fd | lines | where {|i| ($i =~ '_')}
'grow/ansi_edu.pdf' | str replace '(.*)/(.*)_(.*)$' '$1-$2'
'grow/ansi_edu.pdf' | str replace '(.*)/(.*)_(.*)$' '$1/$3'
fd | lines | where {|i| ($i =~ '_')} | each {|i| mv -v $i ($i | str replace '(.*)/(.*)_(.*)$' '$1/$3')}
fd | lines | where {|i| ($i =~ '_')} | each {|i| ($i | str replace '(.*)/(.*)_(.*)$' '$1/$3')}
'grow/ansi_edu_cat.pdf' | str replace '(.*)/(.*)_(.*)$' '$1/$3'
fd | lines | where {|i| ($i =~ '_')} | each {|i| ($i | str replace '(.*)/([^_]*)_(.*)$' '$1/$3')}
fd | lines | where {|i| ($i =~ '_')} | each {|i| ($i | str replace '(.*)/([^_]*)_(.*)_(.*)$' '$1/$3.$4')}
fd | lines | where {|i| ($i =~ '_')} | each {|i| mv -v $i ($i | str replace '(.*)/([^_]*)_(.*)_(.*)$' '$1/$3.$4')}
fd
ls
ls | chmod -x 
chmod  --help | bat --theme 'Solarized (dark)'
tldr chmod
man chmod
tldr chmod
ls | chmod u-x 
ls | each {|i| chmod -x $i}
ls | each {|i| ($i | into string }
ls | each {|i| ($i | into string) }
ls | each {|i| ($i) }
ls | get name | each {|i| chmod -x $i}
fd | lines | each {|i| chmod -x $i}
fd | lines | each {|i| sudo chmod -x $i}
fd
sudo chmod +x booklist cybersecurity growth
sudo chmod +x cs
ch ..
cd ..
exe cs
timer
timer checj
timer check
startup
git status
git commit -am 'sync'
git push
sudo fdisk -l
lsblk
sudo lsblk
polybar_launcher
notify-send --help | bat --theme 'Solarized (dark)'
man notify-send 
less --help | bat --theme 'Solarized (dark)'
less --help | bat 
man --help | bat 
bat   --help | bat --theme 'Solarized (dark)'
bat   --help | bat -p
bat -L
bat -h
bat -h | bat -p
bat -h | less
bat -h | bat -l man
bat -h | bat -nl man
bat -h | bat -l man
rg  --help | bat -l man
bat --list-themes
bat -h
rg --help | bat -l man
man rg 
man rg
man rg 
man fd
lss 
less
less -h
less --help
man ls
man rg
bat --list-themes
man rg
un
man rg
bat --list-themes
man rg
man fd
bat --list-themes
man fd
fd --help | bat -l man --theme 'Solarized (light)'
man fd
fd --help | bat -l man --theme 'Solarized (light)'
 startup
nvim
str replace  --help | bat -l man --theme 'Solarized (light)'
'a b c' |str replace 'a' 'A' 'b' 'B'
let cmd = 'ls'
$cmd
do $cmd
let cmd = {|i| print $i}
'hello' | $cmd
let cmd = 
let cmd = {|i| print 'ls'}
$cmd 
do $cmd
let cmd = {|i| print 'ls'}
do $cmd 
let cmd = {|i| print $i}
do $cmd 
'hola' | do $cmd 
do $cmd 'hola'
let rec = {cmd: {|i| print $i}, file: "path/to/file"}
rec.name
rec.file
rec."file"
$rec.file
do $rec.cmd 'hola'
let cmd = {str replace 'a' 'A'}
do $cmd 'hola'
let cmd = { $in | str replace 'a' 'A'}
do $cmd 'hola'
let cmd = {|i| $i | str replace 'a' 'A'}
do $cmd 'hola'
e
cp  --help | bat -l man --theme 'Solarized (light)'
mv  --help | bat -l man --theme 'Solarized (light)'
bgswitch -l
        let nushell = {file: '~/.config/nushell/config.nu',<\n>            repl_light: {|i| str replace 'solarized_light ' 'solarized_dark '},<\n>            repl_dark: {|i| str replace 'solarized_dark ' 'solarized_light '},<\n>        };<\n>
$nushell.file
$nushell.file | path expand
        let nushell = {file: '~/.config/nushell/config.nu',<\n>            repl_light: {|i| str replace 'solarized_light ' 'solarized_dark '},<\n>            repl_dark: {|i| str replace 'solarized_dark ' 'solarized_light '},<\n>        };<\n>
bgswitch -l
typeoutfileinfo 
        let nushell = {file: '~/.config/nushell/config.nu',<\n>            repl_light: {|i| str replace 'solarized_light ' 'solarized_dark '},<\n>            repl_dark: {|i| str replace 'solarized_dark ' 'solarized_light '},<\n>        };<\n>
bgswitch -l
save  --help | bat -l man --theme 'Solarized (light)'
bgswitch -l
sudo pacman -Rs chromium 
sudo gnome-disks 
yay rufus
sudo fdisk -l
sudo umount /dev/sda1
sudo mount /dev/sda ~/Sync
sudo mount /dev/sda1 ~/Sync
sudo umount /dev/sda1
sudo dd bs=4M if=/home/bo/Downloads/EndeavourOS_Cassini_Nova-03-2023_R1.iso of=/dev/sda1 conv=fsync oflag=direct status=progress
sudo mount /dev/sda1
sudo gnome-disks 
sudo sudo fdisk -l
sudo umount /dev/sdb1
sudo umount /dev/sdb
sudo sudo fdisk -l
sudo umount /dev/sdb2
sudo umount /dev/sdb3
sudo dd if=/home/bo/Downloads/kali-linux-2023.1-installer-amd64.iso of=/dev/sdb status=progress
sudo fdisk -l
 startup
sudo pacman -Ss  --help | bat -l man --theme 'Solarized (light)'
sudo pacman -Ss etcher
sudo pacman -Ss unet
sudo pacman -Ss boot
sudo pacman -S deepin-boot-maker
yay etcher
etcher 
sudo etcher
sudo rofi -run
sudo rofi run
sudo rofi -show run
yay popsicle
sudo popsicle-gtk 
sudo rofi -show run
 ls
git status
git add packages
git commit -am 'sync'
git push
startup
sudo fdisk -l
man dd
sudo bash
sudo cryptsetup --verbose --verify-passphrase luksFormat /dev/sda3\
sudo cryptsetup --verbose --verify-passphrase luksFormat /dev/sda3
sudo cryptsetup luksOpen /dev/sda3 my_usb
sudo mkfs.ext4 -L persistence /dev/mapper/my_usb
startup
 sudo fdisk -l
lsblk
 startup
e
cd (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
find /etc/lightdm/lightdm.conf
find /etc/lightdm/lightdm.conf -h
find -h
open /etc/lightdm/lightdm.conf | find -r '^#autologin-user=$'
open /etc/lightdm/lightdm.conf | find -r "^#autologin-user=$"
open /etc/lightdm/lightdm.conf | find -r "^autologin-user="
open /etc/lightdm/lightdm.conf | find -r "autologin-user="
open /etc/lightdm/lightdm.conf | find -r "^"
open /etc/lightdm/lightdm.conf | find -r "^\#"
open /etc/lightdm/lightdm.conf | find -r "^#"
open /etc/lightdm/lightdm.conf | find -r "^aut"
open /etc/lightdm/lightdm.conf | find -r "#aut"
open /etc/lightdm/lightdm.conf | find -r "#autologin"
open /etc/lightdm/lightdm.conf | find "#autologin"
open /etc/lightdm/lightdm.conf | find "^#autologin$"
open /etc/lightdm/lightdm.conf | find "^#autologin"
open /etc/lightdm/lightdm.conf | find "#autologin"
open /etc/lightdm/lightdm.conf | find "\^#autologin"
open /etc/lightdm/lightdm.conf | find "#autologin"
open /etc/lightdm/lightdm.conf | find "#autologin.*"
open /etc/lightdm/lightdm.conf | find -r "#autologin"
open /etc/lightdm/lightdm.conf | find --regex "#autologin"
open /etc/lightdm/lightdm.conf | find "#autologin"
open /etc/lightdm/lightdm.conf | find "#autologin-user"
open /etc/lightdm/lightdm.conf | find "#autologin-user="
open /etc/lightdm/lightdm.conf | str replace "#autologin-user=$" | blurt
open /etc/lightdm/lightdm.conf | str replace "#autologin-user=$" "blor"
open /etc/lightdm/lightdm.conf | str replace -a "#autologin-user=" "blor"
e /etc/lightdm/lightdm.conf
sudo e /etc/lightdm/lightdm.conf
sudo nvim /etc/lightdm/lightdm.conf
find  --help | bat -l man --theme 'Solarized (light)'
(fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
ls
git status
git add nvim
git commit -am 'sync'
git push
syncthing
startup
true || false
true or false
~/.config/scripts/polybar_launcher
nu ~/.config/scripts/polybar_launcher
$env.config
$env.HOME
sudo thunar
yay nnn
nnn
yay -Rs nnn
syncthing
startup
syncthing
ls
fish
yay go
fish
sudo pacman -Syu
pacman -S archlinux-keyring
sudo pacman -S archlinux-keyring
sudo pacman -Syu
sudo pacman -Syy
sudo pacman -Syu
sudo pacman -Sy endeavouros-keyring
sudo pacman -Syu
startup
yay -S fish
sudo yay -S fish fisher <\n>fisher install laughedelic/pisces<\n>fisher install PatrickF1/fzf.fish<\n>fisher install IlanCosman/tide@v5<\n>fisher install pcr910303/fish-color-manual
sudo yay -S fisher
sudo yay -S fish
fisher install pcr910303/fish-color-manual PatrickF1/fzf.fish IlanCosman/tide@v5 pcr910303/fish-color-manual
l
ls
tree =
tree
e
ls
man --help | bat --theme 'Solarized (dark)'
fish --help | bat --theme 'Solarized (dark)'
echo this is great
fish --help | bat --theme 'Solarized (dark)'
ls
ls.size
(ls).size
(ls).type
^ls
^ls -la
^ls -long
^ls --long
^ls -long
^ls -long | awk '{print $3}'
(ls).size
sleep 2
sleep 2sec
man nu
nu  --help | bat --theme 'Solarized (dark)'
nu ~/.config/scripts/startup
setxkmap us dvorak
setxkbmap us dvorak
remaps
yay gopls
nvim
ps
^ps
^ps aux
^ps au
^ps ax
ps
tasklist
yay go
ps -ef
^ps -ef
go run startup.go
polybar
xrandr 
xrandr | lines
xrandr - --help | bat --theme 'Solarized (dark)'
xrandr --help | bat --theme 'Solarized (dark)'
xrandr --listactivemonitors
e
pgrep polybar
pgrep polybar | complete
(pgrep polybar).exit_code
pgrep "polybar"
pgrep 
pgrep --h
pgrep --help
    while ((pgrep polybar | complete | get exit_code) == 0) {sleep 1sec}<\n>
polybar_launcher
exit  --help | bat --theme 'Solarized (dark)'
fish
fish
fish
nu
fish
fish
 killall -q polybar
    for monitor in (xrandr | lines | where {|i| $i =~ ' connected'} | split column  ' ' | get column1) {<\n>        $"MONITOR=($monitor) polybar --reload main -c ($config) &" | bash<\n>    }<\n>
polybar_launcher
go run startup.go
zellij list-sessions | lines
zellij list-sessions 
go run focus.go tui editor nvim
go run focus.go tui terminal " "
go run focus.go gui firefox
go run focus.go gui firefox firefox
go run focus.go tui lf lf
startup
go run focus.go tui lf lf
nvim
e
go run focus.go tui editor e
go run focus.go tui lf lf
go run scratch.go
alacritty --class lf --title lf -e zellij -l ~/.config/zellij/layout.kdl -s lf
zellij  --help | bat --theme 'Solarized (dark)'
go run focus.go tui lf lf
zellij  -l
zellij  -
zellij  --list-sessions
zellij  --help
zellij  list-sessions
go run focus.go tui lf lf
(fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
go run scratch.go
zellij  list-sessions
go run scratch.go
cd Code/og
cd Code/go
go run scratch.go
fisher
ls
e
ls
open (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
sudo chsh --help | bat --theme 'Solarized (dark)'
fisnh
lf
nvim
xrandr --listactivemonitors 
xrandr --listactivemonitors | lines
xrandr --listactivemonitors | lines | rang 1..
xrandr --listactivemonitors | lines | range 1..
xrandr --listactivemonitors | lines | range 1.. 
xrandr --listactivemonitors | lines | range 1.. | split words 
xrandr --listactivemonitors | lines | range 1.. | split list 
xrandr --listactivemonitors | lines | range 1.. | split list ' ' 
xrandr --listactivemonitors | lines | range 1.. | each {split list ' ' }
xrandr --listactivemonitors | lines | range 1.. | each {|i| $i}
xrandr --listactivemonitors | lines | range 1.. | each {|i| $i }
xrandr --listactivemonitors | lines | range 1.. | each {split row}
xrandr --listactivemonitors | lines | range 1.. | each {split row ' '}
xrandr --listactivemonitors | lines | range 1.. | split row ' '
xrandr --listactivemonitors | lines | range 1.. | each {split row ' '}
xrandr --listactivemonitors | lines | range 1.. | each {split row ' ' }
xrandr --listactivemonitors | lines | range 1.. | each {split row ' ' | get -1}
xrandr --listactivemonitors | lines | range 1.. | each {split row ' ' | get } --help | bat --theme 'Solarized (dark)'
get  --help | bat --theme 'Solarized (dark)'
xrandr --listactivemonitors | tail -n +2 | awk '{print $NF}'
xrandr --listactivemonitors | lines | range 1..
xrandr --listactivemonitors | lines | range 1.. 
xrandr --listactivemonitors | lines | range 1.. | each {split column }
xrandr --listactivemonitors | lines | range 1.. | each {split column ' '}
xrandr --listactivemonitors | lines | range 1.. | each {split list ' '}
xrandr --listactivemonitors | lines | range 1.. | each {split row ' '}
last --help | bat --theme 'Solarized (dark)'
xrandr --listactivemonitors | lines | range 1.. | each {split row ' '}
 xrandr --listactivemonitors | lines | range 1.. | each {split row ' ' | last }
 xrandr --listactivemonitors | lines | range 1.. | each {split row | last }
 xrandr --listactivemonitors | lines | range 1.. | each {split words | last }
 xrandr --listactivemonitors | lines | range 1.. <\n>
 xrandr --listactivemonitors | lines | range 1.. | each {split row ' '} <\n>
 xrandr --listactivemonitors | lines | range 1.. | each {split row ' '| last} <\n>
do --help | bat --theme 'Solarized (dark)'
~/.config/scripts/polybar_launcher
(fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
last --help | bat --theme 'Solarized (dark)'
ps
ls
ls 
ls
htop
fish
fish
fish
fish
e
zellij  list-sessions
set name hello
zellij  list-sessions
zellij  kil-session terminal
zellij kill-session terminal
finsh
zellij zellij  list-sessions
sleep 1
e
chsh -s /bin/fish
sudo chsh -s /bin/fish
sudo chsh -s /bin/fish root
fishsudo chsh -s /bin/fish root
startup
set prog keepassxc flameshot nm-applet  playerctld  xfce4-power-manager  xfce4-screensaver  "unclutter --idle 1"
polybar_launcher
~/.config/scripts/polybar_launcher
let procs = [   <\n>    "numlockx", # activate numlock on startup<\n>    "remaps", # dvorak remappings<\n>    "polybar_launcher" # polybar on all displays<\n>    ]<\n><\n><\n>for proc in $procs {<\n>    $proc<\n>}
$procs
for p in $procs {$p}
for p in $procs {do $p}
let procs = [   <\n>    "numlockx", # activate numlock on startup<\n>    "remaps", # dvorak remappings<\n>    "polybar_launcher" # polybar on all displays<\n>    "echo hello"<\n>    ]<\n><\n><\n>for proc in $procs {<\n>    $proc<\n>}
do  --help | bat --theme 'Solarized (dark)'
~/.config/scripts/startup
e
zellij list-sessions | lines | any {$i =~ $name}
zellij list-sessions | lines | any {|i| $i =~ $name}
zellij list-sessions | lines | any {|i| $i =~ editor}
zellij list-sessions | lines 
lf
lf --help | bat --theme 'Solarized (dark)'
^lf --help | bat --theme 'Solarized (dark)'
lf
bash
 flatpak install flathub org.fedoraproject.MediaWriter
yay flatpak
 flatpak install flathub org.fedoraproject.MediaWriter
sudo mediawriter
flatpak run org.fedoraproject.MediaWriter
sudo flatpak run org.fedoraproject.MediaWriter
sudo -i flatpak run org.fedoraproject.MediaWriter
su -l --help | bat --theme 'Solarized (dark)'
$BAT_THEME
$env.BAT_THEME
bat  --help | bat --theme 'Solarized (dark)'
bat --help | bat --theme 'Solarized (dark)'
rg  --help | bat --theme 'Solarized (dark)'
man rg
yay sway
startup
ls
$env
$env.config
$env.config.color_config
ls
$env.config.color_config
git status
git add alacritty/
git add alacritty nushell nvim obsidian polybar rofi scripts 
git status
git commit -am 'sync'
git push
git push --set upstream master master
sudo -i flatpak run org.fedoraproject.MediaWriter
sudo -i
lsl
ls
sudo dnf install tldr i3-wm i3status i3lock qalculate-gtk bc alacritty zathura zathura-pdf-mupdf arandr htop mpv git curl libtool xorg-xset texlive-core latexmk pavucontrol pipewire-pulse flameshot ripgrep fzf rofi light xclip xdg-utils xdotool wmctrl cmake sxiv fd npm bat neovim unclutter firefox lf pactl pulseaudio pulsemixer polybar ffmpeg syncthing clementine playerctl keepassxc blueman lxappearance xcape xfce4-power-manager xfce4-screensaver starship zellij cargo
sudo dnf search i3
sudo dnf search lf
sudo dnf search lf file
sudo dnf search lf manager
dnf enable copr enable pennbauman/ports
sudo dnf copr enable pennbauman/ports
dnf install lf<\n>
sudo dnf install lf
udo dnf install tldr i3 i3status i3lock qalculate-gtk bc alacritty zathura zathura-pdf-mupdf arandr htop mpv git curl libtool xorg-xset texlive-core latexmk pavucontrol pipewire-pulse flameshot ripgrep fzf rofi light xclip xdg-utils xdotool wmctrl cmake sxiv fd npm bat neovim unclutter firefox lf pactl pulseaudio pulsemixer polybar ffmpeg syncthing clementine playerctl keepassxc blueman lxappearance xcape xfce4-power-manager xfce4-screensaver starship zellij cargo
sudo dnf install tldr i3 i3status i3lock qalculate-gtk bc alacritty zathura zathura-pdf-mupdf arandr htop mpv git curl libtool xorg-xset texlive-core latexmk pavucontrol pipewire-pulse flameshot ripgrep fzf rofi light xclip xdg-utils xdotool wmctrl cmake sxiv fd npm bat neovim unclutter firefox lf pactl pulseaudio pulsemixer polybar ffmpeg syncthing clementine playerctl keepassxc blueman lxappearance xcape xfce4-power-manager xfce4-screensaver starship zellij cargo
sudo dnf copr enable dawid/xcape
sudo dnf copr enable atim/starship
vi .config/nvim/lua/user/treesitter.lua
sudo dnf search zellij
ls
sudo dnf search iosevka
ls
cat packages
ls
thunar &
thunar
cat packages
cd .config/
ls
cat packages
thunar
sudo dnf -y install tldr i3 i3status i3lock qalculate-gtk bc alacritty zathura zathura-pdf-mupdf arandr htop mpv git curl libtool xset flameshot ripgrep fzf rofi light xclip xdg-utils xdotool wmctrl cmake sxiv fd-find npm bat neovim unclutter firefox pulseaudio pavucontrol pamix pasystray polybar ffmpeg-free syncthing clementine playerctl keepassxc blueman lxappearance xcape xfce4-power-manager xfce4-screensaver zellij
sudo dnf -y --skip-broken install tldr i3 i3status i3lock qalculate-gtk bc alacritty zathura zathura-pdf-mupdf arandr htop mpv git curl libtool xset flameshot ripgrep fzf rofi light xclip xdg-utils xdotool wmctrl cmake sxiv fd-find npm bat neovim unclutter firefox pulseaudio pavucontrol pamix pasystray polybar ffmpeg-free syncthing clementine playerctl keepassxc blueman lxappearance xcape xfce4-power-manager xfce4-screensaver zellij
xcape
dnf clean packages
sudo dnf install xcape
git clone https://github.com/alols/xcape.git
sudo dnf install git
git clone https://github.com/alols/xcape.git
cd xcape
make
sudo dnf install git gcc make pkgconfig libX11-devel libXtst-devel libXi-devel
make
sudo make install
sudo dnf -y install tldr i3 i3status i3lock qalculate-gtk bc alacritty zathura zathura-pdf-mupdf arandr htop mpv curl libtool xset flameshot ripgrep fzf rofi light xclip xdg-utils xdotool wmctrl cmake sxiv fd-find npm bat neovim unclutter firefox pulseaudio pavucontrol pamix pasystray polybar ffmpeg-free syncthing clementine playerctl keepassxc blueman lxappearance xcape xfce4-power-manager xfce4-screensaver zellij git gcc make pkgconfig libX11-devel libXtst-devel libXi-devel
sudo dnf -y --skip-broken install tldr i3 i3status i3lock qalculate-gtk bc alacritty zathura zathura-pdf-mupdf arandr htop mpv curl libtool xset flameshot ripgrep fzf rofi light xclip xdg-utils xdotool wmctrl cmake sxiv fd-find npm bat neovim unclutter firefox pulseaudio pavucontrol pamix pasystray polybar ffmpeg-free syncthing clementine playerctl keepassxc blueman lxappearance xcape xfce4-power-manager xfce4-screensaver zellij git gcc make pkgconfig libX11-devel libXtst-devel libXi-devel
 sudo dnf copr enable peterwu/iosevka
sudo dnf search iosevka
sudo dnf install iosevka-fonts
ls
iosevka
lf
mkdir ~/.themes ~/.fonts
sudo chsh -s /usr/bin/nu root
chsh -s /usr/bin/nu
chsh -l
fd . ~/.config/scripts -tf -x chmod +x {}
fd-find
fd
sudo dnf search fd-find
sudo dnf install fd-find
fd . ~/.config/scripts -tf -x chmod +x {}
sudo cp -r ~/.config/fonts ~/.fonts
sudo systemctl enable sshd
ls
this 
biatch
remaps
ls
sudo dnf search xset
sudo dnf install xset
zellij
sudo dnf -y --skip-broken install tldr i3 i3status i3lock qalculate-gtk bc alacritty zathura zathura-pdf-mupdf arandr htop mpv curl libtool xset flameshot ripgrep fzf rofi light xclip xdg-utils xdotool wmctrl cmake sxiv fd-find npm bat neovim unclutter firefox pulseaudio pavucontrol pamix pasystray polybar ffmpeg-free syncthing clementine playerctl keepassxc blueman lxappearance xcape xfce4-power-manager xfce4-screensaver zellij git gcc make pkgconfig libX11-devel libXtst-devel libXi-devel
sudo dnf copr -h
sudo dnf copr disable dawid/xcape
sudo dnf -y --skip-broken install tldr i3 i3status i3lock qalculate-gtk bc alacritty zathura zathura-pdf-mupdf arandr htop mpv curl libtool xset flameshot ripgrep fzf rofi light xclip xdg-utils xdotool wmctrl cmake sxiv fd-find npm bat neovim unclutter firefox pulseaudio pavucontrol pamix pasystray polybar ffmpeg-free syncthing clementine playerctl keepassxc blueman lxappearance xcape xfce4-power-manager xfce4-screensaver zellij git gcc make pkgconfig libX11-devel libXtst-devel libXi-devel
zellij
ls
nvim
 remaps
sudo dnf search ldf
sudo dnf search ld
sudo dnf search ld | lines
sudo dnf install gcc
sudo dnf search ld gnu
sudo dnf search clang
sudo dnf search clang++
sudo dnf search g++
sudo dnf search g plus
sudo dnf install gcc-g++
e
sudo dnf obsidian
sudo dnf search obsidian
flatpak install flathub md.obsidian.Obsidian
sudo dnf install flatpak
flatpak install flathub md.obsidian.Obsidian
dnf copr enable alxhr0/Obsidian 
sudo dnf copr enable alxhr0/Obsidian 
sudo dnf install Obsidian
sudo dnf search Obsidian
sudo dnf search obsidian
flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
dnf copr disable alxhr0/Obsidian 
sudo dnf copr disable alxhr0/Obsidian 
ls
e
flatpak install flathub md.obsidian.Obsidian
polybar_launcher
startup
sudo light -h
sudo light -A 10
sudo light -A 10 -v3
light -A 10 -v3
bat /etc/light/targets/sysfs/backlight/auto/minimum
extract (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
extract Breeze-Solarized-Light.tar.tar
cd bo/
cd Downloads/
extract Breeze-Solarized-Light.tar.tar
mkdir ~/.themes ~/.fonts
sudo cp -r ~/.config/themes  /usr/share/themes/
flatpak run md.obsidian.Obsidian
sudo fdisk -l
ls
ls -h
ls -l
ls 
ls -d
man rg
ls
rg --help | bat --theme 'Solarized (dark)'
rg --help | bat
rg  --help | bat
grep --help | bat
ls  --help | bat
ps  --help | bat
fd --help | bat
man fd
fd  --help | bat
man fd
fd -h
fd --help
fd -h
ls -h | bat
fd -h | bat
rg -h | bat
$env.BAT_THEME
bat .bashrc
ls
ls -d
lf
sudo gnome-disks 
sudo dnf install gparted
sudo gparted
polybar_launcher
 startup
startup
polybar_launcher
remaps
~/.config/scripts/remaps # dvorak remappings<\n>
startup
sudo dnf autorand
sudo dnf search autorand
sudo dnf search autorandr
sudo dnf install autorandr
autorandr -h | bat
man autorandr 
tldr autorandr
autorandr
autorandr --save home
autorandr
man autorandr
polybar_launcher
autorandr
autorandr --force home
polybar_launcher
timer check
timer -s start timer 1hr
timer stop
let  -h | bat
timer start timer
check
ps
ps 
(ps).name | any {$in ~= "timer"}
any -h | bat
(ps).name | any {|i| $i == "timer"}
(ps).name | any {str contains "timer"}
(ps).name | any {str contains "timer"} -h | bat
(ps).name | any {str contains "firefox"} 
(ps).name | any {str contains "timer"} 
(ps).name 
ps
^ps aux
^ps aux 
^ps aux | rg 'timer'
ps -h | bat
ps -l
ps -l 
ps 
ps -l | command
ps -l | get command
ps -l | get command 
ps -l | get command | str contains "timer"
ps -l | get command | any {str contains "timer"}
ps
ps -l | where -h | bat
ps -l 
ps -l | where {command ~= "timer"}
ps -l | where {$in.command ~= "timer"}
ps -l | where {$in.command = "timer"}
ps -l | where {$in.command == "timer"}
ps -l | where {$in.command | str contains "timer"}
ps -l | get command
ps -l | get command 
ps -l | get command | any {str contains "timer"}
ps -l | where {$in.command | str contains "timer"}
ps -l | where {$in.command | str contains "timer"} | get pid
get  -h | bat
ps -l | where {$in.command | str contains "timer"} | get pid.1
ps -l | where {$in.command | str contains "timer"} | get pid.0
kill -h | bat
ps -l | where {$in.command | str contains "timer"} | get pid.0 | kill 
timer check
ps -l | where {get command | str contains "timer"} | get pid.0
timer start stopwatch
ps -l | where {get command | str contains "timer"} | get pid.0
ps -l | where {get command | str contains "timer"}
ps -l | any {get command | str contains "timer"}
ps -l
timer check
ps -l
timer check
timer start stopwatch
<\n>def kill_processes [] {<\n>    if (ps -l | any {get command | str contains "timer"}) {<\n>        let pid = (ps -l | where {get command | str contains "timer"} | get pid.0)<\n>        kill $pid<\n>    } <\n>}
timer check
for i in (seq 5) {<\n>    timer check<\n>}
for i in (seq 5) {timer check; sleep 1sec}
for i in (seq 5) {timer check; sleep 1sec; print $i}
for i in (seq 5) {print (timer check); sleep 1sec; print $i}
seq 5
seq ..5
seq -h | bat
for i in (range 5) {print (timer check); sleep 1sec; print $i}
for i in (seq 1 5) {print (timer check); sleep 1sec; print $i}
for i in (seq 1 5) {print (timer check); sleep 1sec}
while {print (timer check); sleep 1sec}
while true {print (timer check); sleep 1sec}
while true {print (timer check); sleep 0.1sec}
while true {print (timer check); sleep 0.001sec}
while true {print (timer check)}
 while true {print 'f'}
 while true {print $env.PATH}
 while true {print $env.PATH }
 while true {print $env.PATH | str join}
$env.PATH 
$env.PATH | str join 
for i in (seq 1 1000) {$env.PATH | str join }
for i in (seq 1 1000) {$env.PATH | str join  }
for i in (seq 1 1000) {$env.PATH | str join |echo }
for i in (seq 1 1000) { print ($env.PATH | str join) }
print -h | bat
for i in (seq 1 1000) { print -n ($env.PATH | str join) }
sudo dnf search neofetcrh
sudo dnf search neofetch
sudo dnf install neofetch
neofetch
sudo dnf list | count -h | bat
length -h | bat
sudo dnf list | length
sudo dnf list |  length
sudo dnf list | lines | length
sudo dnf list 
sudo dnf list | length
sudo dnf list | lines |length
sudo dnf -h
sudo dnf info
sudo dnf info | lines
first
sudo dnf info | lines | where { str contains "Name.*:"}
first -h | bat
sudo dnf info | lines | first 200
split
sudo dnf info | lines | first 200 | where {str contains "Name"}
sudo dnf info | lines | first 200 | where {str contains "Name"} | split words
sudo dnf info | lines | first 200 | where {str contains "Name"} | split row " "
sudo dnf info | lines | first 200 | where {str contains "Name"} | split list " "
sudo dnf info | lines | first 200 | where {str contains "Name"} | each {split list " "}
sudo dnf info | lines | first 200 | where {str contains "Name"} | each {$in | split list " "}
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column " "
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column " " 
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column " " | get column11
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column "{\s}*" | get column11
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column "{ }*" | get column11
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column " *"
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column "\s*"
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column "{ }*"
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column "[ ]*"
sudo dnf info | lines | first 200 | where {str contains "Name"} | split words
sudo dnf info | lines | first 200 | where {str contains "Name"} | each {split words}
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column " "
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column " " | get column11
sudo dnf info | lines | first 200 | where {str contains "Name"} | split column " " | get column11 | my cocoo
sudo dnf info | lines | where {str contains "Name"} | split column " " | get column11 | length
sudo dnf info | lines | where {str contains "Name"} 
sudo dnf info | lines | where {str contains "Name"} | length
sudo dnf install chromium
sudo dnf search q torrent
sudo dnf search qbittorrent
sudo dnf instal qbittorrent
sudo dnf install qbittorrent
pulsemixer --change-volume +2 --max-volume 100
pamix --change-volume +2 --max-volume 100
pulsemixer
pa
pasystray
sudo dnf search ffm
sudo dnf install ffmpeg-free
sudo dnf install gstreamer1-plugins-{bad-\*,good-\*,base} gstreamer1-plugin-openh264 gstreamer1-libav --exclude=gstreamer1-plugins-bad-free-devel
ls
ps
ps -
ps -l | where {|i| $i.command |str contains "timer"} | get pid.0
ps -l | where {|i| $i.command | str contains "timer"} | get pid.0
ps -l | where {|i| $i.command | str contains "firefox"} | get pid.0
curl -s  -h | bat
let input = "helsinki distance"
let question_string = ([[i]; [($input | str join ' ')]] | to-url)
let question_string = ([[i]; [($input | str join ' ')]] | url)
let question_string = ([[i]; [($input | str join ' ')]] )
[[i]; [($input | str join ' ')]]
[[($input | str join ' ')]]
[($input | str join ' ')]
[($input | str join ' ')] | url -h | bat
[($input | str join ' ')] | url join
[[i]; [($input | str join ' ')]] | url join
[[i]; [($input | str join ' ')]] | url join -h | bat
[[i]; [($input | str join ' ')]] | url join 
url
url parse
url encode -h | bat
[[i]; [($input | str join ' ')]] | url encode
 [($input | str join ' ')] | url encode
use -h | bat
use  -h | bat
use help
help use
wa helsinki switzerland distance
url  -h | bat
url  encode -h | bat
["abc"] |str join
["abc"] 
wa helsinki switzerland distance
curl -s 
wa helsinki switzerland distance
curl -s
curl -si
curl -h
wa helsinki switzerland distance
wa distance between helsinki and zurich
wa what is the biggest known prime
wa what is most popular developer language
wa most popular developer language
wa double integral of sine
wa 800 * 900
wa "(800 * 23)^2"
wa 2000 per month, how many is that in a day
wa 2000 per month => per day
wa 2000 querys per mont
wa 2000 querys per month
wa 2000 querys per month into daily
wa 2000/month = per day
wa 2000/month => per day
wa 2000/month =
wa 2000 * 12 / 365
wa 2000 * 12 / 365 exact
wa 2000 * 12 / 365 float
wa 2000 * 12 / 365 not exact
wa is my ass
wa energy of living human
zathura  -h | bat
zathura ~/Books/cs/rust_programming_lang.pdf# i read every day, first thing i do on the computer, so i want the book to be there starting up<\n>
zathura ~/Books/cs/rust_programming_lang.pdf # i read every day, first thing i do on the computer, so i want the book to be there starting up<\n>
flameshot -h | bat
flameshot -g
flameshot
^flameshot
^flameshot --help
flameshot gui
xrandr --listactivemonitors 
xrandr 
xrandr
xrandr  -h | bat
xrandr  --help
xrandr  --listmonitors
xrandr
xrandr --help
xrandr -q
xrandr -q | lines 
xrandr -q | lines | where {str contains "connected"}
xrandr -q | lines | where {str contains "connected"} | split column
xrandr -q | lines | where {str contains "connected"} | split column " "
xrandr -q | lines | where {str contains " connected"} | split column " " 
xrandr -q | lines | where {str contains " connected"} | split column " " | get column1
nvim
rofi  -h | bat
rofi filebrowser
rofi -show filebrowser
rofi -show windowcd
rofi -show  -h | bat
rofi -dmenu
man rofi 
rofi-dmenu
man rofi-dmenu
rofi-dmenu -h
man rofi-dmenu
rofi -dmenu -p "monkey"
rofi -dmenu -p "monkey: "
[a, b, c] | rofi -dmenu -p "monkey: "
[a, b, c] |str join | rofi -dmenu -p "monkey: "
[a, b, c] |str join "\n" | rofi -dmenu -p "monkey: "
[a, b, c] | str join "\n" | rofi -dmenu -p -x "Displays: "
[a, b, c] | str join "\n" | rofi -dmenu -x -p "Displays: "
[a, b, c] | str join "\n" | rofi -dmenu -multi-select -p "Displays: "
e
let monitors = (xrandr -q | lines | where {str contains " connected"} | split column " " | get column1)<\n>$monitors | rofi -dmenu -multi-select -p "Displays: "
let monitors = (xrandr -q | lines | where {str contains " connected"} | split column " " | get column1 | str join "\n")<\n>$monitors | rofi -dmenu -multi-select -p "Displays: "
xrandr 
xrandr -h
xrandr --h
xrandr --help
tldr xrandr
xrandr --auto
x (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
displayselect 
xrandr -q | lines | where {str contains " connected"} | split column " " | get column1
    let monitors = (xrandr -q | lines | where {str contains " connected"} | split column " " | get column1)<\n>    print $monitors<\n>
displayselect 
let on = [d1, d2, d2]
d1 in $on
print ("d1" in $on)
print ("d3" in $on)
print ("d2" in $on)
displayselect 
print ("d2" in $on)
displayselect 
xrandr -h | bat
xrandr --help | bat
displayselect 
ls
syncthing
polybar_launcher
man nu
man rg
ls  -h | bat
ls
zellij list-sessions | lines 
zellij
lf
cd ~
nvim
(fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
cargo init lifetimes_testing
cargo run
xed
xset
xprop
xev
nm-applet
polybar_launcher
network-manager
nm-connection-editor 
syncthing
cargo init randmaxima_alg
syncthing
wa rust collections
cargo run
xautolock
sudo dnf search xautolock
sudo dnf install xautolock
xautolock -time 10 -locker "systemctl suspend && i3lock"
i3lock -h | bat
man i3lock 
sudo dnf remove xfce4-power-manager
sudo dnf remove xfce4-screensaver
xautolock -time 30 -locker 'i3lock -e --color fdf6e3' && systemctl suspend
xautolock -time 30 -locker 'i3lock -e --color fdf6e3' && systemctl suspend | bash
    "xautolock -time 30 -locker 'i3lock -e --color fdf6e3 && systemctl suspend' &" | bash
git status
git remove xfce4/
get  -h | bat
git -h | bat
git rm xfce4
git status
git rm -r xfce4
git rm -rf xfce4
git status
git commit -am 'sync'; git push
wa "a[1] =1; a[n+1] = 2*a[n] +1"
 udevadm monitor -u -t seat -s input -s usb
sudo dnf search automounter
sudo dnf search mount
sudo dnf search autofs
sudo dnf install autofs
xrandr
startup
ps
ps 
(ps).name | str contains "xauto"
# program name and launch command<\n>let progs = [<\n>    {"keepassxc": "keepassxc"},<\n>    {"flameshot": "flameshot"},<\n>    {"nm-applet": "nm-applet"},<\n>    {"playerctld": "playerctld"},<\n>    {"unclutter": "unclutter"}, # hides mousecursor<\n>    {"firefox": "firefox"},<\n>    {"zathura": "zathura"}, # i read books everyday<\n>    {"Obsidian": "flatpak run md.obsidian.Obsidian"}, # i take notes everyday<\n>    {"xautolock": "xautolock -time 30 -locker 'i3lock -e --color fdf6e3 && systemctl suspend'"}, # lock the screen after 30min<\n>]
$progs
# program name and launch command<\n>let progs = [<\n>    ["name", "command"];<\n>    ["keepassxc", "keepassxc"],<\n>    ["flameshot", "flameshot"],<\n>    ["nm-applet", "nm-applet"],<\n>    ["playerctld", "playerctld"],<\n>    ["unclutter", "unclutter"], # hides mousecursor<\n>    ["firefox", "firefox"],<\n>    ["zathura", "zathura"], # i read books everyday<\n>    ["Obsidian", "flatpak run md.obsidian.Obsidian"], # i take notes everyday<\n>    ["xautolock", "xautolock -time 30 -locker 'i3lock -e --color fdf6e3 && systemctl suspend'"], # lock the screen after 30min<\n>]<\n><\n>
$progs
startup
ps 
ps | str contains obsid
ps | str contains "obsid"
ps | get name | str contains "obsid"
ps | get name | where {str contains obs}
ps | where {str contains obs}
ps | where {get name | str contains obs}
startup
nmtui
sudo dnf search nmtui
sudo dnf search nm tui
sudo dnf search nm-tui
sudo dnf search tui network
sudo dnf install NetworkManager-tui
nm-tui
nmtui
syncthing
ls
lf
fd. 
fd .
fd . -x chmod -x 
wa 2 pow 5
2 pow 3
wa 2 pow 4
bc -l
syncthing
x (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
(fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
nu (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
(fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
scratch.un
scratch.nu
x scratch.nu
exe scratch.nu
exec scratch.nu
./scratch.nu
[1 2 3 4] | enumerate
man [1 2 3 4] | enumerate
 -h | bat
enumerate  -h | bat
clip
std clip -h | bat
let<\n>for in in letter
nu
nu
nu
nu
nu
nu
this 
let<\n>for in in letter
let<\n>for in in letter\
ls
eao
this 
greac
ls
err
ls
nls
ls
great
fuck
this si great
this "is <\n><\n>"
tihs 
un
ls
err
ls
tihs 
great
suck
ls
success
ls
occ
this 
great
ls
this 
ls
tihs 
greant
ls
this is great
ls
ech
let a = 122<\n>let c = [1 2 3]<\n>for i in c {<\n>    print $i<\n>}
let a = 122<\n>let c = [1 2 3]<\n>for i in c {<\n>    print $i a<\n>}
let a = 122<\n>let c = [1 2 3]<\n>for i in c {<\n>    print $ia<\n>}
ls
cargo init cacher_testing
 syncthing 
sudo dnf install pipewire-pulseaudio --allowerasing
yay pulseaudio
sudo dnf search pulsemx
sudo dnf search pulsemin
sudo dnf search pulsemi
sudo dnf install ffmpeg-libs
sudo dnf search ffmpeg-libs
sudo dnf search ffmpeg
pactl set-sink-volume @DEFAULT_SINK@ +2%
systemctl --user start pipewire-pulse.service pipewire-pulse.socket<\n>
pactl set-sink-volume @DEFAULT_SINK@ +2%
 cargo install xremap --features x11   # X11
sudo xremap config.yml
cd .cargo/
./xremap
xremap config.yml
sudo xremap config.yml
sudo ~/.cargo/bin/xremap config.yml
md xremap
touch config.yml
xremap config.yml
setxkbmap us dvorak
xremap config.yml
sudo xremap config.yml
sudo ~/.cargo/bin/xremap config.yml
remaps
syncthing
"xremap ~/.config/xremap/config.yml &" | bash
xremap ~/.config/xremap/config.yml
sudo xremap ~/.config/xremap/config.yml
sudo ~/.cargo/bin/xremap ~/.config/xremap/config.yml
startup
nvim
sudo dnf search java
sudo dnf search javac
sudo dnf search java com
sudo dnf search openjdk
git statu
git status
git add xremap
git commit -am 'sync'; git push
dnfs java development
dnfs openjdk
dnfs java-latest
dnfs java-latest-openjdk
dnfi java-latest-openjdk
sudo dnf search jdtls
dnfs java language server
dnfs java language
dnfs eclips jd
dnfs eclips 
dnfs eclipse 
dnfs openjdk
dnfs java-latest-openjdk-devel
dnfi java-latest-openjdk-devel
sudo dnf search jdtls
dnfs jdt lang
javac hello_world.java
cd enums_test/
javac Main.java
ls -la
ls -h
java Main
javac Main.java
java Main
javac Main.java
java Main
javac Main.java
java Main
javac Main.java
ps 
ps | get name | $in ~= xremaps
ps | get name | where str contains xremaps
ps | get name | where (str contains xremaps)
ps | get name 
startup
ps | get name | where (str contains xremap) 
true in (ps | get name | str contains xremap)
ps | get name | str contains xremap
 git status
git commit -am 'sync'; git push
syncthing
killall syncthing
syncthing
javac Main.java
rg . 'leader_layout'
rg 'leader_layout' .
rg 'leader_layout'
git status
git add zellij
git commit -am 'sync'; git push
javac Main.java
bat packages
./packages
xremap ~/.config/xremap/config.yml
./packages
xremap
$env.PAT
$env.PATH
bat commands
bat packages
cargo install xremap --features x11
ls
dnfi tmux
lf
ls
tree
lf
thsi 
tmux
tmux 
tree
this is greatness
ls
xremap
startup
bat ./scripts/startup
ps | get name | str contains xremap
sudo xremap ~/.config/xremap/config.yml
sudo su
startup
dnfi wine
dns wine
dnfs wine
dnfi wine
startu
startup
bat packages
dnfs xautolock
dnfi xautolock
startup
dnfs pipewire
startup
sudo fdisk -l
lsblk
tldr lsblk
lsblk -a
sudo fdisk -l
sudo fdisk -l | find /dev
sudo fdisk -l | find --regex "^/dev"
sudo fdisk -l | find  -h | bat
sudo fdisk -l | find -r '^/dev'
sudo fdisk -l | find -r '/dev'
sudo fdisk -l | find -r '^\/dev'
sudo fdisk -l | find -r '^.dev'
sudo fdisk -l | find -r '.dev'
sudo fdisk -l | find  -h | bat
sudo fdisk -l | find  -rm ^/dev
sudo fdisk -l | find  -rm "^\/dev"
sudo fdisk -l | find  -mr "^\/dev"
sudo fdisk -l | find  -mr "^$"
sudo fdisk -l | lines | find  -mr "^$"
sudo fdisk -l | lines | find  -mr "^/dev$"
sudo fdisk -l | lines | find  -mr "^/dev"
sudo fdisk -l | lines | find  -mr "^/dev" | column
sudo fdisk -l | lines | find  -mr "^/dev" | columns
sudo fdisk -l | lines | find  -mr "^/dev" | split column 
sudo fdisk -l | lines | find  -mr "^/dev" | split column ' '
sudo fdisk -l | lines | find  -mr "^/dev" | split words
sudo fdisk -l | lines | find  -mr "^/dev" | split column '\s'
sudo fdisk -l | lines | find  -mr "^/dev" | split column ''
sudo fdisk -l | lines | find  -mr "^/dev" | split column ' '
sudo fdisk -l | lines | find  -mr "^/dev" | split column '\t'
sudo fdisk -l | lines | find  -mr "^/dev" | split column  -h | bat
sudo fdisk -l | lines | find  -mr "^/dev" | split column  -r '\s*'
sudo fdisk -l | lines | find  -mr "^/dev" | split column  -r '\s'
sudo fdisk -l | lines | find  -mr "^/dev" 
sudo fdisk -l | lines | find  -mr "^/dev" | split column  -r '\s*'
sudo fdisk -l | lines | find  -mr "^/dev" | split column  -r \s*
sudo fdisk -l | lines | find  -mr "^/dev" | split column  
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -h | bat
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\t'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '{\s}*'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '*{\s}'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s{*}'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s{2}'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s*'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '(\s*)'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s*'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '[\s*]'
sudo fdisk -l | lines | find  -mr "^/dev" 
ls
^ls
^ls -la
^ls -la | lines | split column -r '\s*'
split column  -h | bat
['a bbbb       c' 'a     bb  c'] | split column -r '\s*'
split column  -h | bat
['a bbbb       c' 'a     bb  c'] | split column -r '\s\s'
['a bbbb       c' 'a     bb  c'] | split column -r '\s\s*'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s\s*'
sudo fdisk -l | lines | find  -mr "^/dev" | split words
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s\s*'
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s\s*' | get column1
    let disks: table = sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s\s*'
    let disks: table = (sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s\s*')
disks
$disks
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s\s*' | get column1
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s\s*' | head -h | bat
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s\s*' | header -h | bat
rename -h | bat
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s\s*' | header -h | bat
sudo fdisk -l | lines | find  -mr "^/dev" | split column   -r '\s\s*' 
sudo fdisk -l | lines 
sudo fdisk -l | find -r '^Device'
sudo fdisk -l | find -mr '^Device'
sudo fdisk -l | lines |find -mr '^Device'
find  -h | bat
str contains  -h | bat
str  -h | bat
sudo fdisk -l | lines | where {str starts-with 'Device' }
each while  -h | bat
take -h | bat
sudo fdisk -l | lines | where {str starts-with 'Device' | take 10}
sudo fdisk -l | lines | where {str starts-with 'Device'} | take 10
drop  -h | bat
skip  -h | bat
sudo fdisk -l | lines | skip until {str contains 'Device'}
sudo fdisk -l | lines | skip until (str contains 'Device')
sudo fdisk -l | lines | skip until {true}
sudo fdisk -l | lines | skip until {str starts-with 'D'}
sudo fdisk -l | lines | skip until {|x| $x | str starts-with 'D'}
sudo fdisk -l | lines | skip until {str starts-with 'D'}
sudo fdisk -l | lines | skip until {$in str starts-with 'D'}
sudo fdisk -l | lines | skip until {$in | str starts-with 'D'}
sudo fdisk -l | lines | find  -mr "^/dev"
sudo fdisk -l | lines | find  -mr "^Device"
find -h | bat
sudo fdisk -l | lines | skip until {|x| $x | str starts-with 'D'}
sudo fdisk -l | lines | skip until {|x| $x | str starts-with '^D'}
sudo fdisk -l | lines | skip until {|x| $x | str starts-with 'D'}
sudo fdisk -l | lines | skip until {|x| str starts-with 'D'}
sudo fdisk -l | lines | skip until {|x| $x starts-with 'D'}
str  -h | bat
str starts-with  -h | bat
[1 2 3 4] | skip until {|x| $x >= 3}
['a' 'b' 'c'] | skip until {|x| $x == 'a'}
['a' 'b' 'c'] | skip until {|x| $x == 'b'}
['a' 'b' 'c'] | skip until {|x| $x =~ 'b'}
['accc' 'aoeu' 'cooaobaoeu' 'aoeub'] | skip until {|x| $x =~ 'b'}
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'}
sudo fdisk -l | lines | skip until {|x| $x }
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'}
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until -h | bat
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == '^$'}
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == '^\s*$'}
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == '\s*'}
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''}
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | header
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | headers
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers |into string
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | str join '\n'
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | str join ''
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | each {str join '\'}
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | each {str join ' '}
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | into string
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str join '\n'
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str join -h | bat
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | into string
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | into string | echo
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | echo
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | print
parse
parse -h | bat
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | parse 
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | parse '{dev start end sectors size end}'
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | parse '{dev} {start} {end} {sectors} {size} {end}}'
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | parse '{dev} {start} {end} {sectors} {size} {end}'
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | parse -r '\s\s*'
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device 
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | into binary 
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | into string 
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str collect -h | bat
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str join  -h | bat
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str join 
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str join ' \n '
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str join '\n' | ^echo
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str join '\n' | echo
echo (sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str join '\n')
sudo fdisk -l | lines | skip until {|x| $x =~ 'Device'} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str join '\n'
['asoeuh' 'sathoeu' aseotuh] 
['asoeuh' 'sathoeu' aseotuh] | str join '\n'
['asoeuh' 'sathoeu' aseotuh] | str join  -h | bat
['asoeuh' 'sathoeu' aseotuh] | str join  "\n"
sudo fdisk -l | lines | skip until {|x| $x =~ Device} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str join \n
sudo fdisk -l | lines | skip until {|x| $x =~ Device} | take until {|x| $x == ''} | split column -r \s\s* | headers | get Device | str join "\n"
sudo fdisk -l | lines | skip until {|x| $x =~ "Device"} | take until {|x| $x == ""} | split column -r "\s\s*" | headers | get Device | str join "\n"
sudo fdisk -l | lines | skip until {|x| $x =~ "Device"} | take until {|x| $x == ""} | split column -r \s\s* | headers | get Device | str join "\n"
sudo fdisk -l | lines | skip until {|x| $x =~ "Device"} | take until {|x| $x == ""} | split column -r \s\s* | headers | get Device | str join \n
sudo fdisk -l | lines | skip until {|x| $x =~ "Device"} | take until {|x| $x == ""} | split column -r \s\s* | headers | get Device | str join "\n"
sudo fdisk -l | lines | skip until {|x| $x =~ "Device"} | take until {|x| $x == ""} | split column -r \s\s* | headers | get Device | str join '\n'
sudo fdisk -l | lines | skip until {|x| $x =~ "Device"} | take until {|x| $x == ""} | split column -r \s\s* | headers | get Device | str join "\n"
sudo fdisk -l | lines | skip until {|x| $x =~ "Device"} | take until {|x| $x == ""} | split column -r \s\s* | headers | get Device | str join \n
xset r rate 300 70 # key repeat rate speedup
x (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
(fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
mount
    let disks = (    sudo fdisk -l     | lines     | skip until {|x| $x =~ 'Device'}     | take until {|x| $x == ''}     | split column -r \s\s*     | headers    ) # contains disk data in table
$disks
sudo fdisk 
sudo fdisk -l
$disks
$disks.Device
$disks.Device | str join "\n" | rofi -dmenu -p "Choose disk to mount: "
$disks.Type | str join "\n" | rofi -dmenu -p "Choose disk to mount: "
$disks | str join "\n" | rofi -dmenu -p "Choose disk to mount: "
read -h | bat
read  -h | bat
read --help
input  -h | bat
Choose Disk \(1..($disks |length)\): 
print "Choose Disk \(1..($disks |length)\): "
print $"Choose Disk \(1..($disks |length)\): "
$disks
mount 
    let disks = (    sudo fdisk -l     | lines     | skip until {|x| $x =~ 'Device'}     | take until {|x| $x == ''}     | split column -r \s\s*     | headers    ) # contains disk data in table    print $disks
    let disks = (<\n>    sudo fdisk -l <\n>    | lines <\n>    | skip until {|x| $x =~ 'Device'} <\n>    | take until {|x| $x == ''} <\n>    | split column -r \s\s* <\n>    | headers<\n>    ) # contains disk data in table<\n>    print $disks
mnt  -h | bat
mnt
mounter
$disks.1
mounter
$disks.1
$disks | get 1
mounter
sudo umount /dev/nvme0n1p4
sudo umount tmp
nvim
e
dnfs red
dnfs redshift
dnfi redshift-gtk
redshift
lf
git status
git add nushell
git commit -am 'sync'; git push
tree \
tree /
tree /
syncthing
git statu
git status
htop
def tester [inp: string] {<\n>    if $inp == null {<\n>        print "null"<\n>    } else {<\n>        $inp<\n>    }<\n>}
tester
def tester [inp?: string] {<\n>    if $inp == null {<\n>        print "null"<\n>    } else {<\n>        $inp<\n>    }<\n>}
tester 
tester hello
to -h | bat
"hEllO" | str downcase
focus tui editor
focus tui htop
mut cmd = ''
$cmd = 11
cmd = 'aaaaa'
$cmd
let comm = "hollea"
$comm
cmd -h | bat
$cmd
cmd = 'aaa'
let cmd = 'aaa'
$cmd
focus tui htop
let cmd
focus tui htop
focus tui htop htop
focus tui htop
dnfs xfce4
dnfs xfce4-scr
sudo dnf  -h | bat 
sudo dnf info xfce
sudo dnf info xfce4-screensaver
sudo dnf install xfce4-screensaver
dnfr xfce4-screensaver
dnfr xfce4-power-manager
dnfr xfce4-screensaver-preferences
dnfr xdg-screensaver
xautolock  -h | bat
xautoleck
xautolock
xautolock -exit
wa derivative of log(a)
wa "derivative of log(a)"
wa "derivative of log(a^b)"
wa "derivative of log(a**b)"
wa "derivative of log(a**4)"
wa "derivative of log(2a**4)"
population switzerland
wa "population switzerland"
wa "population switzerland town ammerswil"
wa "population switzerland town lenzburg"
wa "number of students ethz"
wa "number of computer science students ethz"
wa "number of students ethz"
wa "number of students mit"
wa "number of students caltec"
wa "when invention of money"
wa "when was money first used"
wa "s"
wa "umlaut"
wa "sharp s"
wa "sharp S"
wa "zathura"
wa "zathura software"
wa "software zathura"
wa "linux"
wa "gnu"
wa "gnu software"
wa "gnu software foundation"
wa "free software foundation"
wa "derivative of log(sqrt(log(m)))"
syncthing
focus tui zathura zathura
focus gui zathura zathura
javac Card.java
javac Card.java "l"
javac Card.java 
java Main
Java Card
Java Card.class
java Card.class
java Card.java
javac Card.java 
java Card.java
javac Card.java; java Card.java
java -h | bat
javac Card.java; java Card.java
mv card_ex/ caret_ex
javac Caret; java Caret.java
javac Caret.java; java Caret.java
mv Card.java Caret.java
javac Caret.java; java Caret.java
javac Caret.java
java Caret.java
javac Caret.java; java Caret.java
javac Caret.java; java Caret.java=
javac Caret.java; java Caret.java
javac Caret.java
java Caret.java
javac Caret.java; java Caret.java
rm Card.class
rm Caret.class
rm Card.java
javac Caret.java
java Caret.java
mounter
sudo fdisk -l
sudo mount /dev/sda1 ~/mnt/ 
sudo thuner
sudo thunar
sudo umount mnt
sudo umount /dev/sda1
klil
killall xautolock
 syncthing 
killall xautolock
man xset
tldr xset
ps | get name | str contains xset
tldr xset
xset r  -h | bat
xset s off # no screensaver either on or locked with xautolock after 30min
bash -c	grep -qP -m1 '[^un]bind.+\/[^:]+\(usb\)' <(udevadm monitor -u -t seat -s input -s usb)
udevadm monitor -u -t seat -s input -s usb
sudo xset s off
xset s off
bc -l
syncthing
startup
tldr zathura
pip install calcure
dnfi pi
dnfi pip
pip install calcure
calcure
 calcure
sudo dnfi calcurse
dnfi calcurse
pip  -h | bat 
pip  uninstall calcure
calcurse 
cal
cal  -h | bat
date
date now
date format
date humanize
date now | date to-record
date now | date humanize
date now | date to-record
date now | date to-table
take -h | bat
date now | date to-record
date now | date to-record | take 3
date now | date to-record | first 3
date format -h | bat
date format -l
date now | date format "%Y_%m_%d.md"
let d = "~/Notes"
let n = daily_template.md
path join  -h | bat
$d | path join $n
if !true
if not true
if not (true)
if not (2  == 2) { print h}
if (2  == 2) { print h}
if !(2  == 2) { print h}
if true or false {print a}
if false or false {print a}
nvim ~/Notes/
nvim ~/Notes
file  -h | bat
cp  -h | bat
mv  -h | bat
cp -h | bat
cp  -h | bat
touch test.txt
mv test.txt Notes/taste.txt
cd .config/
x(fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
x (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf --reverse)
makenote
    let daily_notes = "~/Notes/daily_notes"<\n>    let today_title = (date now | date format "%Y_%m_%d.md")<\n>    let todays_note = ($daily_notes | path join $today_title)
$todays_note
makenoet
makmakenote
makenote
$todays_note | path exists
<\n>    let daily_notes = "~/Notes/daily_notes"<\n>    let today_title = (date now | date format "%Y-%m-%d.md")<\n>    let todays_note = ($daily_notes | path join $today_title)<\n>    let daily_template = "~/Notes/templates/daily_template.md"
$todays_note | path exists
makenote 
dailynete
dailynote 
flatpak remove flathub md.obsidian.Obsidian
dnfi calcurse
flatpak install flathub md.obsidian.Obsidian
calcurse
man calcurse
man calcurse | less
cp layout.kdl leader_layout.kdl
git status
git add zellij/
git add calcurse/
git add scripts/
git commit -am 'sync'; git push
startup
makenote
dailynote 
alacritty -e nvim ~/.config/
git st
git status
git git commit -am 'sync'; git push
git commit -am 'sync'; git push
flatpak remove flathub md.obsidian.Obsidian
nvim ~/Notes
zellij kill-server
nvim
e
ls
cd daily_notes/
ls | get name | split list '-'
ls | get name 
ls | get name | each {|x| split list '-'}
ls | get name | each {|x| split words}
ls | get name | each {|x| split column }
ls | get name | each {|x| split column '-'}
ls | get name | split column '-'
ls
cd .
cd..
ls
cd ..
ls
cd 2023
for i in (seq 3 6) {mkdir $i}
for i in (seq 3 6| into string ) {mkdir $i}
rm -r 3
rm -r 4 5
rm -r 6
for i in (seq 3 6 | into string) {mkdir $i}
ls
ls | skip 1
ls | skip 1 | get name
ls | skip 1 | get name | each {|x| mv $x (["0", $x] | str join '')} 
ls
ls | get name | split column '-' 
ls | get name | split column '-' | get column 2
ls | get name | split column '-' | get column2
ls | get name 
ls | get name | each {|x| print $x ("../2023" | path join ($x | split column '-' | get column2 ) | path join $x)}
ls | get name | each {|x| print $x ("../2023" | path join ($x | split list '-' | get 2 ) | path join $x)}
split words
split words -h | bat
ls | get name | each {|x| print $x ("../2023" | path join ($x | split words  | get 2 ) | path join $x)}
ls 
cd ../daily_notes/
ls | get name | split words
ls | get name | split list
ls | get name | split list '-'
ls | get name | split row
ls | get name | split row '-'
ls | get name | split column '-'-
ls | get name | split column '-'
ls | get name | each {|x| print $x ("../2023" | path join ($x | split column '-' | get column2 | into string ) | path join $x)}
ls | get name | each {|x| print $x ("../2023" | path join ($x | split column '-' | get column2 )}
ls | get name | each {|x| print $x ("../2023" | path join ($x | split column '-' | get column2 ))}
ls | get name | each {|x| print $x ("../2023" |  ($x | split column '-' | get column2 ))}
ls | get name | each {|x| print $x |split column '-'}
ls | get name | each {|x| $x |split column '-'}
ls | get name | each {|x| $x |split column '-' |get column 2}
ls | get name | each {|x| $x |split column '-' |get column2}
ls | get name |split column '-' |get column2 }
ls | get name | split column '-' |get column2 }
ls | get name | split column '-' |get column2 
ls | get name | {|x| split column '-' | get column2 }
ls | get name | {|x| split column '-' | get column2 |print $x }
ls | get name | each{|x| split column '-' | get column2 }
ls | get name | each {|x| split column '-' | get column2 }
ls | get name | each {|x| split-by}
ls | get name | each {|x| split-by head}
split words -h | bat
split chars  -h | bat
ls | get name | each {|x| split column '-'}
ls | get name | split column '-'
ls | get name | split column '-' | each {|x| echo $x }
ls | get name | split column '-' | each {|x| echo $x ("../2023" | path join $x.column2)}
ls | get name | each {|x| echo $x ("../2023" | path join $x.column2)}
ls | get name | each {|x| echo $x ("../2023" | path join ($x | split column '-' | get column2)}
ls | get name | each {|x| echo $x ("../2023" | path join ($x | split column '-' | get column2) }
ls | get name | each {|x| echo $x ("../2023" | path join ($x | split column '-' | get column2)) }
ls | get name | each {|x| echo $x ("../2023" | path join ($x | split column '-' | get column2 | flatten)) }
ls | get name | each {|x| echo ($x | split column '-' | get column2 )) }
ls | get name | each {|x| echo ($x | split column '-' | get column2 ) }
ls | get name | each {|x| echo ($x | split column '-' | get column2.0 ) }
ls | get name | each {|x| echo ($x | split column '-' ) }
ls | get name | each {|x| echo $x ("../2023" | path join ($x | split column '-' | get column2.0 )) }
ls | get name | each {|x| echo $x ("../2023" | path join ($x | split column '-' | get column2.0 ) | path join $x) }
ls | get name | each {|x| mv $x ("../2023" | path join ($x | split column '-' | get column2.0 ) | path join $x) }
ls | get name | each {|x| echo $x ("~/journal/2023" | path join ($x | split column '-' | get column2.0 ) | path join $x) }
cd 20200
open `2022-00-00.md`
for i in (open `2022-00-00.md`) {print $i}
open `2022-00-00.md` | lines
open `2022-00-00.md` | lines | find -h | bat
open `2022-00-00.md` | lines | find '###'
open `2022-00-00.md` | lines | find -r '^### \d'
for line in (open `2022-00-00.md`) {if ($line =~ "^### \d") {print $line}}
for line in (open `2022-00-00.md`) {if ($line =~ "^### ") {print $line}}
for line in (open `2022-00-00.md`) {if ($line =~ "### ") {print $line}}
open `2022-00-00.md` | lines | find -r '^### \d'
for line in (open `2022-00-00.md`) {<\n>    if ($line | str starts-with '### ') {<\n>        print $line<\n>    }<\n>}
for line in (open `2022-00-00.md`) {<\n>    if ($line | str starts-with '###') {<\n>        print $line<\n>    }<\n>}
for line in (open `2022-00-00.md`) {if ($line =~ "### ") {print $line}}
for line in (open `2022-00-00.md`) {if ($line | str starts-with "### " ) {print $line}}
for line in (open `2022-00-00.md`) {if ($line | str starts-with '### ' ) {print $line}}
open `2022-00-00.md` | lines 
open `2022-00-00.md` | lines | split column "\n" 
open `2022-00-00.md` | lines | split column \n
open `2022-00-00.md` | lines | each {split column \n}
open `2022-00-00.md` | lines | each {split list "\n"}
open `2022-00-00.md` | lines | each {split row "\n"}
open `2022-00-00.md` | lines | each {split row "\n"} | flatten 
open `2022-00-00.md` | lines | each {split row "\n"} | flatten -h
open `2022-00-00.md` | lines | each {split row "\n"} | split list ''
open `2022-00-00.md` | lines | each {split row "\n"} | split list null
open `2022-00-00.md` | lines | each {split row "\n"} | range -h | bat
open `2022-00-00.md` | lines | each {split row "\n"} 
takke -h | bat
take -h | bat
open `2022-00-00.md` | lines | each {split row "\n"} | take until null
open `2022-00-00.md` | lines | each {split row "\n"} | take while not null
open `2022-00-00.md` | lines | each {split row "\n"} | take while (not null)
take until  -h | bat
open `2022-00-00.md` | lines | each {split row "\n"} | take until {|x| == null}
open `2022-00-00.md` | lines | each {split row "\n"} | take until {|x| == ''}
open `2022-00-00.md` | lines | each {split row "\n"} | take until {|x| = []}
open `2022-00-00.md` | lines | each {split row "\n"} | take until {|x| $x == []}
open `2022-00-00.md` | lines | each {split row "\n"} 
open `2022-00-00.md` | lines | each {split row "\n"} | get 0 
open `2022-00-00.md` | lines | each {split row "\n"} | each {flatten} 
open `2022-00-00.md` | lines | each {split row "\n"} | flatten
open `2022-00-00.md` | lines | take until {|x| $x == '\n'}
open `2022-00-00.md` | lines 
open `2022-00-00.md` | lines | take until {|x| $x == ''}
open `2022-00-00.md` | lines | take while {|x| $x == ''}
open `2022-00-00.md` | lines | take while {|x| $x != ''}
open `2022-00-00.md` | lines | take while {|x| $x == ''}
open `2022-00-00.md` | lines | take while {|x| $x != ''}
open `2022-00-00.md` | lines | enumerate
split-by "\n\n"
open `2022-00-00.md` | split-by  "\n\n"
open `2022-00-00.md` | lines | split-by "\n\n"
open `2022-00-00.md` | str collect | split-by "\n\n"
open `2022-00-00.md` | str join | split-by "\n\n"
open `2022-00-00.md` | lines | get 0
open `2022-00-00.md` | lines | get 0 | index
get  -h | bat
split-by -h | bat 
open `2022-00-00.md` | lines 
open `2022-00-00.md` | lines | split row '\s'
open `2022-00-00.md` | lines | split row '\n'
open `2022-00-00.md` | lines | split row "\n"
open `2022-00-00.md` | lines | split row "n"
open `2022-00-00.md` | lines | split list a
open `2022-00-00.md` | lines 
open `2022-00-00.md` | lines | take 4
open `2022-00-00.md` | lines | take 4 | length 
mut end = ((open `2022-00-00.md` | lines | take while {|x| $x != ''} | length) -1 )
mut end = ((open `2022-00-00.md` | lines | take while {|x| $x != ''} | length) - 1 )
$end
range -h | bat
let data = (open `2022-00-00.md`) <\n>mut begin = 0<\n>mut end (($data| lines | take while {|x| $x != ''} | length) - 1)<\n>for i in ($data | range $begin $end) {<\n>    print $i<\n>}
let data = (open `2022-00-00.md`) <\n>mut begin = 0<\n>mut end = (($data| lines | take while {|x| $x != ''} | length) - 1)<\n>for i in ($data | range $begin $end) {<\n>    print $i<\n>}
let data = (open `2022-00-00.md`) <\n>mut begin = 0<\n>mut end = (($data| lines | take while {|x| $x != ''} | length) - 1)<\n>for i in ($data | range ($begin)..($end)) {<\n>    print $i<\n>}
let data = (open `2022-00-00.md`) <\n>mut begin = 0<\n>mut end = (($data| lines | take while {|x| $x != ''} | length) - 1)
$end
$begin
$data | range 0..($end)
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ''} | length) - 1)<\n>for i in ($data | range ($begin)..($end)) {<\n>    print $i<\n>}
open `2022-00-00.md` | lines 
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != '### '} | length) - 1)<\n>for i in ($data | range ($begin)..($end)) {<\n>    print $i<\n>}
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| ($x | str starts-with "### ")} | length) - 1)<\n>for i in ($data | range ($begin)..($end)) {<\n>    print $i<\n>}
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| ($x | str starts-with '###')} | length) - 1)<\n>for i in ($data | range ($begin)..($end)) {<\n>    print $i<\n>}
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x =~  '###'} | length) - 1)<\n>for i in ($data | range ($begin)..($end)) {<\n>    print $i<\n>}
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data | take while {|x| $x =~  '###'} | length) - 1)<\n>for i in ($data | range ($begin)..($end)) {<\n>    print $i<\n>}
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data | take while {|x| $x =~  '###'} | length) - 1)<\n>$end
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data | take while {|x| ($x | str starts-with '###'} | length) - 1)<\n>$end
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data | take while {|x| ($x | str starts-with '###')} | length) - 1)<\n>$end
$data | take until {|x| $x =~ "#"}
$data
$data | take until {|x| $x =~ "\#"}
$data | take until {|x| $x =~ "a"}
$data | take until {|x| x =~ "a"}
$data | take until {|x| $x =~ "a"}
take -h | bat
take until -h | bat
$data | take until {|x| $x = ""}
$data | take until {|x| $x = " "}
$data | take until {|x| $x == ""}
$data | take until {|x| $x ~= ""}
$data | take until {|x| $x != ""}
$data | take until {|x| $x == ""}
$data | take until {|x| ($x | str starts-with '') }
$data | take until {|x| ($x | str starts-with '#') }
$data | take until {|x| ($x | str starts-with '\#') }
$data | take until {|x| $x == ""}
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x == ""} | length) - 1)<\n>$end<\n>for i in ($data | range ($begin)..($end)) {<\n>    print $i<\n>}
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x == ""} | length) - 1)<\n>$end<\n># for i in ($data | range ($begin)..($end)) {<\n>#     print $i<\n># }
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>$end<\n># for i in ($data | range ($begin)..($end)) {<\n>#     print $i<\n># }
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>for i in ($data | range ($begin)..($end)) {<\n>    print $i<\n>}
let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>touch test.txt<\n>for i in ($data | range ($begin)..($end)) {<\n>    $i | save -a test.txt<\n>}
bat test.txt
save -h | bat
rm test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>mut paragraph = []<\n>for i in ($data | range ($begin)..($end)) {<\n>    $paragraph | append $i<\n>}<\n>$paragraph
rm test.txt<\n>touch test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>mut paragraph = []<\n>for i in ($data | range ($begin)..($end)) {<\n>    $paragraph | append $i<\n>}<\n>$paragraph
touch test.txt
rm test.txt<\n>touch test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>mut paragraph = []<\n>for i in ($data | range ($begin)..($end)) {<\n>    $paragraph | append $i<\n>}<\n>$paragraph
rm test.txt<\n>touch test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>mut paragraph = []<\n>for i in ($data | range ($begin)..($end)) {<\n>    $paragraph | append $i<\n>    print $i<\n>}<\n>$paragraph
append -h | bat
rm test.txt<\n>touch test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>mut paragraph = [aa]<\n>for i in ($data | range ($begin)..($end)) {<\n>    $paragraph | append $i<\n>    print $i<\n>}<\n>$paragraph
rm test.txt<\n>touch test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>mut paragraph = [aa]<\n>for i in ($data | range ($begin)..($end)) {<\n>    $paragraph | append ($i | into string)<\n>}<\n>$paragraph
str -h | bat
rm test.txt<\n>touch test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>mut paragraph =  [1, 2]<\n>for i in ($data | range ($begin)..($end)) {<\n>    $paragraph | append $i<\n>}<\n>$paragraph
rm test.txt<\n>touch test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>mut paragraph =  [1, 2]<\n>for i in ($data | range ($begin)..($end)) {<\n>    $paragraph | append "aa"<\n>}<\n>$paragraph
rm test.txt<\n>touch test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>mut paragraph =  [1, 2]<\n>for i in ($data | range ($begin)..($end)) {<\n>    paragraph | append "aa"<\n>}<\n>$paragraph
rm test.txt<\n>touch test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>$data | range ($begin)..($end) | save test.txt<\n>bat test.txt
rm test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>$data | range ($begin)..($end) | save test.txt<\n>bat test.txt
rm test.txt<\n>let data = (open `2022-00-00.md` | lines) <\n>mut begin = 0<\n>mut end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>while $end != ($data | length) {<\n>    $data | range ($begin)..($end) | save test.txt<\n>    begin = $end<\n>    end = (($data| | take while {|x| $x != ""} | length) - 1)<\n>}<\n>bat test.txt
let data = (open `2022-00-00.md` | lines) <\n>($data| | take while {|x| $x != ""}) | save test<\n>bat test
rm test
touch test
open test | length
cp  `2022-00-00.md` old.md
open old.md | skip 3
open old.md 
skip  -h | bat
drop -h | bat
skip 1
open old.md | skip 1
open old.md | skip 1 | str join
open old.md | lines
open old.md 
open old.md | lines
open old.md | lines | skip 1
open old.md | lines | skip 1000
open old.md | lines | skip 10000
while (open 'old.md' | lines| length) == 0 {<\n>    let data = (open `old.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""}) | <\n>    $paragraph | save test<\n>    $data | skip ($paragraph | length)<\n>}<\n>bat test
while (open 'old.md' | lines| length) == 0 {<\n>    let data = (open `old.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save test<\n>    $data | skip ($paragraph | length)<\n>}<\n>bat test
open old.md | lines 
open old.md | lines | length 
while (open 'old.md' | lines| length) != 0 {<\n>    let data = (open `old.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save test<\n>    $data | skip ($paragraph | length)<\n>}<\n>bat test
while (open 'old.md' | lines| length) != 0 {<\n>    let data = (open `old.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f test<\n>    $data | skip ($paragraph | length)<\n>}<\n>bat test
cp -f -h | bat
cp  -h | bat
cp `2022-00-00.md` old.md
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) != 0 {<\n>    let data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f out.md<\n>    data = $data | skip ($paragraph | length)<\n>    print $data<\n>    "" | save -f out.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) != 0 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f out.md<\n>    data = $data | skip ($paragraph | length)<\n>    print $data<\n>    "" | save -f out.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) != 0 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f out.md<\n>    $data = $data | skip ($paragraph | length)<\n>    print $data<\n>    "" | save -f out.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) != 0 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    print $data<\n>    $paragraph | save -f out.md<\n>    # $data = $data | skip ($paragraph | length)<\n>    "" | save -f out.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) != 0 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    print $data<\n>    $paragraph | save -f out.md<\n>    # $data = $data | skip ($paragraph | length)<\n>    rm copy.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) > 1 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    print $data<\n>    $paragraph | save -f out.md<\n>    # $data = $data | skip ($paragraph | length)<\n>    "" | save -f copy.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) > 1 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    print $data<\n>    $paragraph | save -f out.md<\n>    $data = $data | skip ($paragraph | length)<\n>    "" | save -f copy.md<\n>}<\n>bat test
open old.md | lines | rang 1..10
open old.md | lines | range 1..10
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) > 1 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    print $data<\n>    $paragraph | save -f out.md<\n>    $data = ($data | skip ($paragraph | length))<\n>    "" | save -f copy.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) > 1 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f out.md<\n>    $data = ($data | skip ($paragraph | length))<\n>    print $data<\n>    "" | save -f copy.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) > 1 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f out.md<\n>    $data = ($data | skip 1000)<\n>    print $data<\n>    "" | save -f copy.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) > 1 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f out.md<\n>    print ($paragraph | length)<\n>    $data = ($data | skip ($paragraph | length))<\n>    print $data<\n>    "" | save -f copy.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) > 1 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f out.md<\n>    $data = ($data | skip ($paragraph | length))<\n>    print $data<\n>    "" | save -f copy.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) > 1 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f out.md<\n>    $data = ($data | skip ($paragraph | length + 1))<\n>    print $data<\n>    "" | save -f copy.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) > 1 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f out.md<\n>    $data = ($data | skip (($paragraph | length ) + 1))<\n>    print $data<\n>    "" | save -f copy.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>while (open 'copy.md' | lines| length) > 1 {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f out.md<\n>    print ($data | skip (($paragraph | length ) + 1)) <\n>    $data = ($data | skip (($paragraph | length ) + 1))<\n>    "" | save -f copy.md<\n>}<\n>bat test
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 5) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip (($paragraph | length ) + 1))<\n>}<\n>bat test<\n><\n># while (open 'copy.md' | lines| length) > 1 {
ls | get name | find tmp 
ls | get name | find tmp | rm 
ls | get name | find tmp | each {|x| rm $x}
save  -h | bat
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 5) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip (($paragraph | length ) + 1))<\n>    $data | save -f 'copy.md'<\n>}<\n>bat test<\n><\n># while (open 'copy.md' | lines| length) > 1 {
ls | get name | find tmp | each {|x| rm $x}
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 5) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    # $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip (($paragraph | length ) + 1))<\n>    $data<\n>}<\n>bat test<\n><\n># while (open 'copy.md' | lines| length) > 1 {
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 5) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    # $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip ($paragraph | length ))<\n>    $data<\n>}<\n>bat test<\n><\n># while (open 'copy.md' | lines| length) > 1 
bat copy.md
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 5) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    # $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip ($paragraph | length ))<\n>    $paragraph | length<\n>}<\n>bat test<\n><\n># while (open 'copy.md' | lines| length) > 1
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 5) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    # $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip ($paragraph | length ))<\n>    print ($paragraph | length)<\n>}<\n><\n># while (open 'copy.md' | lines| length) > 1
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 5) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    # $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip ($paragraph | length ))<\n>    print $data<\n>}<\n><\n># while (open 'copy.md' | lines| length) > 1
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 1) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    # $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip (($paragraph | length ) + 1))<\n>    print $data<\n>}<\n><\n># while (open 'copy.md' | lines| length) > 1
save -h | bat
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 3) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    # $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip (($paragraph | length ) + 1))<\n>    print $data | str join "\n"<\n>    # $data | str join "\n" <\n>}<\n><\n># while (open 'copy.md' | lines| length) > 1
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 3) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    # $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip (($paragraph | length ) + 1))<\n>    print ($data | first 50 | str join "\n")<\n>    # $data | str join "\n" <\n>}<\n><\n># while (open 'copy.md' | lines| length) > 1
collect -h | bat
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 3) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    # $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip (($paragraph | length ) + 1) | str join "\n")<\n>    print ($data | first 20 )<\n>    # $data | str join "\n" <\n>}<\n><\n># while (open 'copy.md' | lines| length) > 1
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 3) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    # $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip (($paragraph | length ) + 1) | str join "\n")<\n>    print ($data | lines | first 20 )<\n>    # $data | str join "\n" <\n>}<\n><\n># while (open 'copy.md' | lines| length) > 1
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 3) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != ""})<\n>    $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip (($paragraph | length ) + 1) | str join "\n")<\n>    print ($data | lines | first 20 )<\n>    $data | save -f copy.md<\n>}<\n><\n># while (open 'copy.md' | lines| length) > 1
bat `2022-00-00.md`
cp `2022-00-00.md` copy.md <\n>for i in (seq 1 3) {<\n>    mut data = (open `copy.md` | lines) <\n>    let paragraph = ($data| | take while {|x| $x != "***"})<\n>    $paragraph | save -f $"($i).tmp"<\n>    $data = ($data | skip (($paragraph | length ) + 1) | str join "\n")<\n>    print ($data | lines | first 20 )<\n>    $data | save -f copy.md<\n>}<\n><\n># while (open 'copy.md' | lines| length) > 1
flatpak install flathub md.obsidian.Obsidian
zellij kill-session  -h | bat 
zellij kill-session  notes
e
fd .
fd ./
fd .
cd 2023
fd .
fd . -x mv {} ../
fd . 
cd ..
fd . 
ls 
ls | where type == dir
ls | where type == dir | find
ls | where type == dir | find 0
ls | where type == dir | ls  -h | bat
ls | where type == dir 
fd .
fd . -x mv {} ~/journal/
zellij kill-session  notes
e
 synctihng
dnfi emacs
lf
ls
doom install
ls
./doom install
doom sync
./doom sync
emacs
git clone --depth 1 https://github.com/doomemacs/doomemacs ~/.config/emacs
rm -r ~/.config/emacs
git clone --depth 1 https://github.com/doomemacs/doomemacs ~/.config/emacs
~/.config/emacs/bin/doom install
^emacs --daemon
starutp
ps
ps | find emacs
ps  -h | bat
ps  -l | find emacs
ps  -l | get command | find firefox
ps  -l | get command | find flameshot
ps  -l | get command 
ps  -l | get command | find nm
ps  -l | get command | find  xauto
starutup
startup
git status
git add nvim
git add scripts
git add zellij
git commit -am 'sync'; git push
e
doom sync
startup
ls
git status
fd  -h | bat
fd  'sync-conflict'
fd  'sync-conflict' -x rm
fd  'sync-conflict'
git status
git status -h | bat
git status --long
git status -v
git status  -h | bat
bat .git/index
ls
git  -h | bat
git  show
git   -h | bat
git status
ls -/a
ls -la
ls
git statuts
git status
bat readme.org
git status
git commit -am 'sync'; git push
ssh-keygen -t rsa -b 4096 -C "bbotak@protonmail.com"
xclip -h | bat
"aaa" | xclpi
"aaa" | xclip
cat ~/.ssh/id_rsa.pub
git commit -am 'sync'; git push
bash -c eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_rsa<\n>
git commit -am 'sync'; git push
gitt commit
git commit
git commit  -h | bat
git commit  -a
git push
ssh-add ~/.ssh/id_ed25519
ssh-keygen -t ed25519 -C "your_email@example.com"
bash -c eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_ed25519
ssh-keygen -t ed25519 -C "bbotak@protonmail.com"
ssh-add ~/.ssh/id_ed25519
cat ~/.ssh/id_ed25519.pub
git status
git git commit -am 'sync'; git push
git commit -am 'sync'; git push
git init
git status
git add alacritty commands doom fonts htop i3 keepassxc lf mpv nushell nvim packages polybar readme.org rofi scripts starship.toml themes xremap zathura zellij
git status
git  -h | bat
tldr git
git --help
man git 
git remote  -h | bat
man git remote  
git remote add  -h | bat
git remote add master https://github.com/bbotakk/config
ls
git status
git push
git push -h | bat
git push --set upstream master master
git remote -v
git remote add upstream https://github.com/bbotakk/config
git push --set-upstream upstream master
git branch
git remote -v
git remote  -h | bat
git remote  remove upstream
git remote  -h | bat
git remote -v
git branch -h | bat
man git branch 
git branch -l
git branch --show-current
git remote -h | bat
git remote -h | bat add -h | bat
git remote add
git remote add origin -h | bat
git remote remove master
git remote -v
git remote add origin https://github.com/bbotakk/config
git remote -v
git commit -am 'sync'; git push
git commit -am 'sync'; git push --set-upstream origin master
git remote add origin git@github.com:bbotakk/config.git
git remote remove origin
git remote add origin git@github.com:bbotakk/config.git
git remote -v
git status
git git commit -am 'sync'; git push
git commit -am 'sync'; git push
git commit -am 'sync'; git push --set-upstream origin master
git push --help
git push  -h | bat
git commit -am 'sync'; git push --set-upstream origin master -f
dnfs carpace
git status
dnfr qualculate-gtk
dnfs qalculate-gtk
dnfr qalculate-gtk
nu
keepassxc  --help
man keepassxc 
man 
calcurse
lf
syncthing
fd  'sync-conflict'
^emacs --daemon
startup
pandoc
dnfi pandoc
pandoc -s -f html -t org https://www.polyphasic.net/adaptation/strictness-of-sleep-times/ -o output.org
wget -O input.html https://www.polyphasic.net/adaptation/strictness-of-sleep-times/
pandoc -s -f html -t org input.html -o output.org
bat output.org
wget -O input.html https://www.polyphasic.net/adaptation
pandoc -s -f html -t org input.html -o output.org
calcurse
dnfr calcurse
syncthing
dired
emacsclient -c --eval '(delete frame)'
emacsclient -c --eval '(delete-frame)'
emacsclient -c 
ls
git status
syncthing
git status
fd  'sync-conflict'
fd  'sync-conflict' -x rm
git status
emacs --debug-init
^emacs --daemon
^emacs --debug-init
emacs
^emacs
vim .
vi .
^emacs --debug-init
emacs --
^emacs --debug-init
dnfi vi
nvim .
^emacs --debug-init
startup
ps -l | get command
ps -l | get command | find emacs
syncthing
startup
^emacs --daemon
startup
^emacs -nw
startup
emacs --debug-init
^emacs --debug-init
^emacs 
dnfs rust-src
dnfi rust-src
syncthing
dnfs vterm
doom sync
startup
emacs
^emacs
emacs --debug-init
^emacs --debug-init
^emacs
startup
^emacs
cargo run
ls
starutp
startup
syncthing
git status
git commit -am 'sync'; git push
dnfi rust-src
keybindings list
emacs
^emacs
startup
^emacs
syncthing
cargo run  -h | bat
cargo  -h | bat
^emacs --debug-init
^emacs
startup
^emacs
startup
doom sync
ls
^emacs
doom sync
startup
emacs  -h | bat
^emacs  -h | bat
^emacs  --help
startup
emacs -nw
uptime
dnfi pandoc
dnfi rust-src
^emacs --debug-init
startup
^emacs --debug-init
emacs
^emacs
^emacs --debug-init
nvim ~/.config/doom/config.el
^emacs --debug-init
cd .config/doom/
bat packages.el
nvim ~/.config/doom/config.el
^emacs --debug-init
nvim ~/.config/doom/config.el
^emacs --debug-init
nvim ~/.config/doom/config.org
cd .config/doom/
mv config.org ~
^emacs 
nvim config.el
mv config.el ~
^emacs 
mv ~/config.org .
mv config.org ~
mv ~/config.el .
^emacs --debug-init
nvim config.el
ls ~
mv ~/config.org .
nvim config.org
emacs
startup
^emacs --debug-init
^emacs
bat config.el
^emacs
cd ~/Books/
^emacs booklist.org
startup
^emacs booklist.org
startup
^emacs booklist.org
^emacs
^emacs booklist.orgc
^emacs booklist.org
^emacs --eval '(dired-jump)'
^emacs 
startup
^emacs
startup4
startup
emacsclient -c 
startup
emacsclient -c 
^emacs
doom sync
^emacs
doom sync
^emacs
ps -l | get command | find ema
ps -l | get command | find emacs
startup
emacsclient -c 
wmctrl emacs 
wmctrl -xa emacs 
sudo dnfs nuview
dnfs nuview
ls 
ls | nuview
^emacs
ps 
ps | find syncthing
syncthing
"syncthing &" 
"syncthing &" | bash
syncthing -h | bat
man syncthing 
startup
starutp
emacs --daemon
startup
setxkbmap us dvorak
tsnahoeu
startup
keepassxc  --help
man keepass
man keepassxc
man keepassxc-cli
startup
emacsclient --eval '(emacs-everywhere)'
xwininfo
dnfi xwininfo
dnfi xdotool
dnfi xprop
sudo dnf -y --allowerasing install tldr i3 i3status i3lock bc alacritty zathura zathura-pdf-mupdf arandr htop mpv curl libtool xset flameshot ripgrep fzf rofi light xclip xdg-utils xdotool wmctrl cmake sxiv fd-find npm bat unclutter firefox pavucontrol pamix pasystray polybar ffmpeg-free syncthing clementine playerctl keepassxc blueman lxappearance git gcc gcc-g++ make pkgconfig libX11-devel libXtst-devel libXi-devel texlive-scheme-basic latexmk cargo flatpak xautolock autofs emacs pandoc rust-src xwininfo xdotool xprop xclip<\n>
dnfi xclip xdotool xprop xwininfo
startup
sudo xremap ~/.config/xremap/config.yml
xremap ~/.config/xremap/config.yml
sode xremap ~/.config/xremap/config.yml
sudo xremap ~/.config/xremap/config.yml
xremap ~/.config/xremap/config.yml
sudo ~/.cargo/bin/xremap ~/.config/xremap/config.yml
keepassxc  --help
sudo ~/.cargo/bin/xremap ~/.config/xremap/config.yml
vim .
vi .
sudo ~/.cargo/bin/xremap ~/.config/xremap/config.yml
startup
emacs -h | bat
emacs -e '(emacs-everywhere)'
dnfs xdotool
dnfi xdotool
dnfi xprop
dnfi xwininfo
'emacsclient -c --eval "(emacs-everywhere)"' | bash
emacs --eval "(emacs-everywhere)"
emacs -h
emacsclient -h
dnfs xbindkeys
dnfi xbindkeys
touch ~/.xbindkeysrc
xbindkey
xbindkeys
xbindkeys -h | bat
dnfr xbindkeys 
startup
doom sync
ls
git status
git add i3
syncthing
syncthing  -h | bat
man syncthing  
syncthing -h | bat
syncthing -h | bat cli  -h | bat
syncthing cli  -h | bat
syncthing-cli  -h | bat
man syncthing cli 
sycthing continue
syncthing --paused
date
date now
doom sync
emacs  -h | bat
man emacs 
emacs --daemon
^emacs --daemon
git status
syncthing
^emacs --daemon
ls
ls -la
strartup
startup
cd doom/
emacs config.org
doom sync
startup
^emacs
^emacs
startup
doom sync
startup
ps | find syncthing
killall syncthing
syncthing 
ps | find syncthing
kill -h | bat
killall -h | bat
man killall -h | bat
sleep 5min; print aaaa
sleep 5sec; print aaaa
sync_config
$env.PATH
sync_config
dnfi xournalpp
dnfi libreoffice
dnfs wacom
dnfi xorg-x11-drv-wacom
focus tui 'bc -l'
starutp
startup
"" 
"" == nothing
"" == Nothing
"" == null
sync_config 
syncthing
killall syncthing
killall emacs
emacs --daemon
^emacs --daemon
doom sync
git status=
git status
cd doom/
ls
git status
git add snippets
git status
git commit -am 'sync'; git push
syncthing
ipa
ip a
route 
route
emacs --daemon
^emacs --daemon
sync_config 
ls
^emacs --daemon
sync_config 
^emacs --daemon
xprop
startup
setxkbmap us dvorak
startup
^emacs --daemon
sync_config 
^emacs --daemon
sync_config 
killall syncthing
syncthing
pandoc  -h | bat
tldr pandoc
pandoc ~/.config/i3/config.org -o /tmp/config.html; firefox /tmp/config.html
pandoc ~/.config/i3/config.org -o /tmp/config.pdf; firefox /tmp/config.html
pandoc ~/.config/i3/config.org -o /tmp/config.pdf; firefox /tmp/config.pdf
~/.config/i3/config | less
open ~/.config/i3/config | less
open ~/.config/i3/config.org | less
open ~/.config/i3/config.org | bat
tldr bat
bat --list-languages
open ~/.config/i3/config.org | bat  -h | bat
open ~/.config/i3/config.org | bat  -l org
tldr pandoc
pandoc  -h | bat
pandoc ~/.config/i3/config.org -o /tmp/config.pdf --toc; firefox /tmp/config.pdf
pandoc ~/.config/i3/config.org -o /tmp/config.html --toc; firefox /tmp/config.html
rm -f /tmp/config.html; pandoc ~/.config/i3/config.org -o /tmp/config.html --toc; firefox /tmp/config.html
rm -f /tmp/config.html; pandoc ~/.config/i3/config.org -o --toc /tmp/config.html ; firefox /tmp/config.html
rm -f /tmp/config.html; pandoc ~/.config/i3/config.org --toc -o /tmp/config.html ; firefox /tmp/config.html
emacs ~/.config/i3/config.org
startup
ls
starutp
startup
sync_config 
syncthing
startup
^emacs --daemon
git status
sync_config 
killall syncthing
syncthing
6emacs --daemon
^emacs --daemon
doom sync
dnfi xournalpp
dnfi libreoffice
dnfs obs
sudo dnf install kmod-v4l2loopback
flatpak search
flatpak search --help
flatpak search obs
flatpak  -h | bat
flatpak search open broadcast
flatpak install flathub com.obsproject.Studio
ps | find syncthing
"syncthing &" | bash
^emacs --daemon
tree
vi .
vi booklist.org
firefox -h | bat
ps -l 
firefox google.com
ps -l | find google
ps -l | find fier
ps -l | find fire
oracel
oracle
dnfs vm
go install -v github.com/owasp-amass/amass/v3/...@master
extract (fd --hidden -E 'Music/*' -E 'Videos/*' -E 'Pictures/*' -E 'Documents/*' | fzf)
extract amass_Linux_amd64.zip
ls
bat readme.md
bat README.md
./amass
cd amass_Linux_amd64/
mv amass /usr/bin
sudo mv amass /usr/bin
ls /usr/bin
ls /usr/bin _
ls /usr/bin | find amass
amass
amass -h | bat
man amass 
amass -h
syncthing
^emacs --daemon
syncthing
ps | find syncthing=
startup
syncthing=
syncthing
startup
^emacs --daemon
emacs
^\emacs
^emacs
^emacs --daemon
emacs --debug-init
^emacs --debug-init
ps syncthing
ps |find syncthing
syncthing
killall emacs
killall emacsdaemon
^emacs --daemon
startup
^^emacs --daemon
^emacs --daemon
ps -l 
ps -l | get command | find firefox
startup
syncthing
killall syncthing
firefox google.com 
syncthing
startup
starutp
startup
syncthing
tre
ls
cd bo
dnfs oracle vm
dnfs whatweb
dnfi whatweb
whatweb rust.com
whatweb https://rust.com
whatweb https://www.rust.com
whatweb https://www.google.com
whatweb https://www.tesla.com
whatweb http://www.tesla.com
whatweb http://tesla.com
oraclevm
dnfs oraclevm
dnfs vmware
dnfs virtualbox
git clone https://github.com/sudodus/tarballs.git
cd tarballs && tar -xf dus.tar.xz
cd ..
ls
cd dus-tmp/
dus
sudo dus
sudo ./dus
./dus
dnfs mkusb
dnfs do usb
cd ..
bot README.md
bat README.md
ls
cd ..
ls
rm -r org tarballs
git clone https://github.com/sudodus/tarballs.git
ls
./dus-installer
./dus-installer i
dnfs mkusb
cd ..
ls
./dus-installer i
sudo ./dus-installer i
dnfs xterm
dnfi xterm
dnfs pv
dnfi pv
dnfs dialog
sudo ./dus-installer i
dnfs xdialog
dnfs dialog
dnfd dialog
dnfi dialog
sudo ./dus-installer i
dus
ip a
dnfs usb-pack
git clone https://github.com/andreyv/usb-pack-efi.git<\n>
sudo dnf install livecd-tools liveusb-creator<\n>
sudo fdisk -l
^ls
sudo livecd-iso-to-disk --overlay-size-mb 15000 ./Parrot-security-5.3_amd.iso /dev/sdb<\n>
sudo livecd-iso-to-disk --overlay-size-mb 15000 ./Parrot-security-5.3_amd64.iso /dev/sdb<\n>
sudo livecd-iso-to-disk --overlay-size-mb 15000 ./Parrot-security-5.3_amd64.iso /dev/sdb1
sudo fdisk -l
sudo umount /dev/sdX
sudo umount /dev/sdb
sudo mkfs.fat -F32 /dev/sdb
sudo fdisk -l
lsblk -a
sudo mkfs.fat -F32 /dev/sdb1
sudo fdisk /dev/sdb
sudo fdisk -l
sudo mkfs.fat -F32 /dev/sdb1
sudo fdisk /dev/sdX
sudo fdisk /dev/sdb
sudo mkfs.fat -F32 /dev/sdb1
sudo livecd-iso-to-disk --overlay-size-mb 15000 ./Parrot-security-5.3_amd64.iso /dev/sdb1
sudo livecd-iso-to-disk --overlay-size-mb 4096 ./Parrot-security-5.3_amd64.iso /dev/sdb1
sudo livecd-iso-to-disk --overlay-size-mb 4096 Parrot-security-5.3_amd64.iso /dev/sdb1
./dus-installer i
sudo ./dus-installer i
sudo fdisk -l
dnfs nmap
nmap
dnfi nmap
man nmap 
man nmap | less
startup
man man nmap
man nmap
dd if=kali-linux-2023.2-live-amd64.iso of=/dev/sdb1 conv=fsync bs=4M status=progress
ls
sudo dd if=kali-linux-2023.2-live-amd64.iso of=/dev/sdb1 conv=fsync bs=4M status=progress
tldr nmap
ip a
ls
ip a
man nmap
nmap -h | bat
nmap -sL
man nmap
nmap -sn 192.168.1.108
nmap -sn 192.168.1.108/21
ip a
nmap -sn 192.168.1.108/24
nmap -h | bat
tldr nmap
man nmap
man nmap 
man nmap | less
nmap -v -p- 192.168.1.108/24
nmap -v -p- -sU 192.168.1.108/24
sudo nmap -v -p- -sU 192.168.1.108/24
sudo nmap -v -p -sU 192.168.1.108/24
nmap  -h | bat
man nmap
bash -c sudo su
sudo nmap -v --top-ports 1000 -sU 192.168.1.108/24
sudo nmap -v -sT 192.168.1.108/24
sudo nmap -sT 192.168.1.108/24
let data = (sudo nmap -sT 192.168.1.108/24)
ls
$data
$data 
$data | where str starts-with "\d"
$data | where str starts-with '\d'
let mut data = (data |lines)
let mut data = ($data |lines)
mut data = ($data |lines)
$data
$data | where str starts-with '\d'
$data | where { str starts-with '\d'} 
$data | where { str starts-with "\d" } 
$data | where { str starts-with "8" } 
$data
$data
str contains  -h | bat
$data | where  -h | bat
$data | where {|x| $x =~ "^\d.*"}
$data | where {|x| $x =~ "^.*"}
$data | where {|x| $x =~ "^2.*"}
$data | where {|x| $x =~ "^.*"}
$data | where str starts-with "PORT"
str starts-with  -h | bat
where -h | bat
$data | where {$in str starts-with "PORT"}
$data | where {$in | str starts-with "PORT"}
$data 
$data | str starts-with "2"
$data 
$data | find -h | bat
$data | find -r "^2"
$data | find -r "^\d"
$data | find -r "^\\d"
$data | find -r "^\\d" | parse
$data | find -r "^\\d" | parse "{port} {state} {type}"
parse -h | bat
columns -h | bat
$data | find -r "^\\d" | split column
$data | find -r "^\\d" | split column '\s'
$data | find -r "^\\d" | split column "\s"
$data | find -r "^\\d" | split column "\\s"
$data | find -r "^\\d" | split words
$data | find -r "^\\d" | split column -c ' '
$data | find -r "^\\d" | split column -c '   '
$data | find -r "^\\d" | split column -c ' '
parse  -h | bat
head -h | bat
header -h | bat
columns -h | bat
$data | find -r "^\\d" | split column -c ' ' | get column1 
$data
$data | find -r "^\\d" | split column -c ' ' 
$data | find -r "^\\d" 
$data | find -r "^\\d" | parse -r "{port}\\s{state}\\s{type}"
$data | find -r "^\\d" | parse -r "{port}\s{state} {type}"
$data | find -r "^\\d" | parse -r "{port}{state} {type}"
$data | find -r "^\\d" | parse -r "{port} {state} {type}"
$data | find -r "^\\d" | parse "{port} {state} {type}"
$data | find -r "^\\d" | parse "(.*)\s(.*)\s(.*)"
$data | find -r "^\\d" | parse "(.*)\s*(.*)\s*(.*)"
$data | find -r "^\\d" | parse '(.*)\s*(.*)\s*(.*)'
$data | find -r "^\\d" | parse '{a}\s*'
$data | find -r "^\\d" | parse -'{a}\s*'
$data | find -r "^\\d" | parse -r '{a}\s*'
$data | find -r "^\\d" | parse '{a}'
$data | find -r "^\\d" | parse -r '{a}'
$data | find -r "^\\d" | parse -r '.*'
$data | find -r "^\\d" | parse -regex '.*'
$data | find -r "^\\d" | parse --regex '.*'
$data | find -r "^\\d" | parse --regex '(.*)'
$data | find -r "^\\d" | parse --regex '(.*)\s (.*)'
$data | find -r "^\\d" | parse --regex '(.*)\s(.*)'
$data | find -r "^\\d" | parse --regex '(.*)\s(.*)\s(.*)'
$data | find -r "^\\d" | parse --regex '(.*)\s*(.*)\s*(.*)'
$data | find -r "^\\d" | parse --regex '(.*)\s(.*)\s(.*)'
$data | find -r "^\\d" | split column -c ' ' 
$data | find -r "^\\d" | split column -c ' '
$data | find -r "^\\d" | detect columns 
$data | find -r "^\\d" 
let data_raw = (sudo nmap -sT 192.168.1.108/24)
$data_raw
parse  -h | bat
$data_raw | find -rm "^\\d"
$data_raw | find -mr "^\\d"
$data_raw | find -mr "^\d"
$data_raw | find -mr "^22"
$data_raw | lines | find -mr "^22"
$data_raw | lines | find -mr "^"
$data_raw | lines | find -mr "^\\d"
$data_raw | lines | find -mr "^\\d" | split column -c ' '
find -h | bat
split  -h | bat
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | each {column1 | split column -c '/'}
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | each {$in.column1 | split column -c '/'}
ls
ls | update  -h | bat
$data_raw | lines | find -mr "^\\d" | split column -c ' ' 
split column  -h | bat
rename
rename -h | bat
insert
insert -h | bat
str substring  -h | bat
str -h | bat
str trim  -h | bat
spilt  -h | bat
split -h | bat
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|| split column -c '/' | get column2}
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|| split column -c '/' }
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | split column -c '/' }
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | split column -c '/' | get column2}
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | split column -c '/' | get column2 | flatten}
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | split column -c '/' | get column2.0}
str replace  -h | bat
path -h | bat
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename}
update  -h | bat
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename} | update column1 {path dirname}
$data_raw 
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename} | update column1 {path dirname} 
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename} | update column1 {path dirname} | rename port state service protocel\
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename} | update column1 {path dirname} | rename port state service protocol\
$data_raw | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename} | update column1 {path dirname} | rename port state service protocol
(nmap -p -sT (ip a)) | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename} | update column1 {path dirname} | rename port state service protocol
(nmap -sT (ip a)) | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename} | update column1 {path dirname} | rename port state service protocol
ip a
ipaddr
ip addr
ip  -h | bat
ip address-
ip address
ip -h
ip a -h
ip -h a
ip -h a | line
ip -h a | lines
ip -h a | lines | get 8 | split words | get 2
ip -h a | lines | get 8 | split words
ip -h a | lines | get 8 
ip -h a | lines | get 8 | split words
ip -h a | lines | get 8 | split column
ip -h a | lines | get 8 | split column ' '
ip -h a | lines | get 8 | split column -c ' '
ip -h a | lines | get 8 | split column  -h | bat
ip -h a | lines | get 8 | split column -c ' '
str trim
str trim -h | bat
(nmap -p -sT (ip a | lines | get 8 | split column -c ' ' | get column2 | str trim)) | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename} | update column1 {path dirname} | rename port state service protocol
(nmap -sT (ip a | lines | get 8 | split column -c ' ' | get column2 | str trim)) | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename} | update column1 {path dirname} | rename port state service protocol
(nmap -sT (ip a | lines | get 8 | split column -c ' ' | get column2 | str trim)) | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename} | update column1 {path dirname} | rename port state service protocol | save scanned.txt
let $table = ((nmap -sT (ip a | lines | get 8 | split column -c ' ' | get column2 | str trim)) | lines | find -mr "^\\d" | split column -c ' ' | insert protocol {|x| $x.column1 | path basename} | update column1 {path dirname} | rename port state service protocol )
dnfs vbox
dnfs oracle
dnfi VirtualBox-7.0.8_156879_fedora36-1.x86_64.rpm
ls
dnfi VirtualBox-7.0-7.0.8_156879_fedora36-1.x86_64.rpm
sudo /sbin/vboxconfig
dnfi kernel-devel kernel-devel-6.3.6-200.fc38.x86_6
dnfs devel
sudo dnf -y install @development-tools
sudo dnf install kernel-headers kernel-devel dkms  -y
/sbin/vboxconfig
sudo /sbin/vboxconfig
sudo dnf install kernel-devel
sudo /sbin/vboxconfig
sudo dnf install kernel-devel kernel-devel-6.3.6-200.fc38.x86_64
uname -r
sudo dnf install kernel-devel kernel-devel-6.3.6-200.fc38.x86_64
sudo dnf update
arp-scan -l
dnfs arp-scan
dnfi arp-scan
sudo /sbin/vboxconfig
dnfi kernel-devel
dnfi kernel-devel-6.3.6-200.fc38.x86_64
dnfs kernel-devel
dnfs kernel-devel-matched
dnfi kernel-devel-matched
sudo dnf install kernel-headers
sudo /sbin/vboxconfig
sudo dnf install @development-tools
sudo dnf install kernel-headers kernel-devel dkms
"[virtualbox]<\n>name=Fedora $releasever - $basearch - VirtualBox<\n>baseurl=http://download.virtualbox.org/virtualbox/rpm/fedora/$releasever/$basearch<\n>enabled=1<\n>gpgcheck=1<\n>repo_gpgcheck=1<\n>gpgkey=https://www.virtualbox.org/download/oracle_vbox_2016.asc!" | save /etc/yum.repos.d/virtualbox.repo
sudo "[virtualbox]<\n>name=Fedora $releasever - $basearch - VirtualBox<\n>baseurl=http://download.virtualbox.org/virtualbox/rpm/fedora/$releasever/$basearch<\n>enabled=1<\n>gpgcheck=1<\n>repo_gpgcheck=1<\n>gpgkey=https://www.virtualbox.org/download/oracle_vbox_2016.asc!" | save /etc/yum.repos.d/virtualbox.repo
"[virtualbox]<\n>name=Fedora $releasever - $basearch - VirtualBox<\n>baseurl=http://download.virtualbox.org/virtualbox/rpm/fedora/$releasever/$basearch<\n>enabled=1<\n>gpgcheck=1<\n>repo_gpgcheck=1<\n>gpgkey=https://www.virtualbox.org/download/oracle_vbox_2016.asc!" | sud osave /etc/yum.repos.d/virtualbox.repo
"[virtualbox]<\n>name=Fedora $releasever - $basearch - VirtualBox<\n>baseurl=http://download.virtualbox.org/virtualbox/rpm/fedora/$releasever/$basearch<\n>enabled=1<\n>gpgcheck=1<\n>repo_gpgcheck=1<\n>gpgkey=https://www.virtualbox.org/download/oracle_vbox_2016.asc!" | sudo save /etc/yum.repos.d/virtualbox.repo
sudo su
dnfi VirtualBox-7.0.8_156879_fedora36-1.x86_64.rpm
dnfr VirtualBox-7.0-7.0.8_156879_fedora36-1.x86_64.rpm
dnfr VirtualBox
dnfs Virtualbox
dnfr VirtualBox-7.0.x86_64
dnfr VirtualBox-7.0-7.0.8_156879_fedora36-1.x86_64
dnfs VirtualBox
dnfi VirtualBox-7.0.x86_64
dnfr VirtualBox-7.0-7.0.8_156879_fedora36-1.x86_64
dnfr -f VirtualBox-7.0-7.0.8_156879_fedora36-1.x86_64
dnfr -y VirtualBox-7.0-7.0.8_156879_fedora36-1.x86_64
dnfi netdiscover
dnfs netdiscover
netdiscover
dnfs kernel header
dnfs kernel-headers
dnfi kernel-headers
sudo dnf upgrade
sudo dnf update
sudo dnf upgrade --refresh
sudo dnf install kernel-headers
sudo vmware
dnfi kernel-headers
sudo dnfi dkms
do dnfi dkms
dnfi dkms
sudo dnf install gcc kernel-devel kernel-headers make<\n>
ls
bsash
ls
dnfs oracle
dnfs VirtualBox
dnfi VirtualBox-7.0.x86_64
dnfr VirtualBox-7.0.x86_64
dnfi VirtualBox-7.0.x86_64
arp-scan -l
sudo arp-scan -l
ls
arp-scan -l
ls
sudo arp-scan -l
dnfs arp-scan
dnfs nikto
dnfi nikto
sudo arp-scan -l
sudo arp-scan -l | lines
let data = (sudo arp-scan -l | lines)
mut data = ($data |lines)
mut d = ($data |lines)
$data
mut data = (sudo arp-scan -l |lines)
$data
$data | drop 1
$data | range 2..9
$data | range 2..8
$data 
$data range 2..8
$data | range 2..8
$data | range 2..8 | parse "{c1} {c2} {c3}"
$data | range 2..8 | parse "{c1}(.*){c2}(.*){c3}"
$data | range 2..8 | split column ' '
$data | range 2..8 | split column -c ' '
$data | range 2..8 | split words
$data | range 2..8
$data | range 2..8 | split column -c "\s"
$data | range 2..8 | split column -c "\\s"
$data | range 2..8 | split column  -h | bat
$data | range 2..8 | split column  -r "\\s*"
$data | range 2..8 | split column  -r "\\s"
$data | range 2..8 | split column  " "
$data | range 2..8 | split column  -r "\\s"
data = ($data | range 2..8 | split column  -r "\\s" )
$data = ($data | range 2..8 | split column  -r "\\s" )
$data 
for x in $data.column1 { nikto -h $in}
let d = $data
for x in $d {print $in}
$d
for x in $d.colummn1 {nikto -h $x}
for x in $d.column1 {nikto -h $x}
nikto -h 192.168.1.112
nikto -h https://192.168.1.112
nikto -h http://192.168.1.112
nikto -h http://192.168.1.10
nikto -h https://192.168.1.10
nikto -h https://192.168.1.102
nikto -h https://192.168.1.103
nikto -h https://192.168.1.124
sudo arp-scan -l | lines
nmap
nmap -sT
dnfs dirbuster
dnfs gobuster
dnfi gobuster
ip a
netwdiscover -h
netdiscover -h
nmap -sT 192.168.1.108/24
dnfs netdiscover
ls
extract kali-linux-2023.2-vmware-amd64.7z
extract kali-linux-2023.2-virtualbox-amd64(1).7z
dnfs 7z
dnfs p7z
dnfi p7zip
extract kali-linux-2023.2-virtualbox-amd64.7z
extract kali-linux-2023.2-virtualbox-amd64(1).7z
dnfs p7z
dnfi p7zip-gui 
tldr 7z
7z x kali-linux-2023.2-virtualbox-amd64(1).7z\
arp a
arg -h | bat
arp -h | bat
arp
arp | parse "{aaa} {b}"
arp | lines |parse "{aaa} {b}"
arp | lines |parse "{aaa} {b} {c} {d}"
arp | lines |parse "{aaa} {b} {c} "
arp | lines |parse "{aaa} {b} {c}"
arp | lines | parse -r "\\s*(.*)\\s*(.*)"
arp | lines | parse -r "\\s*(.*)"
arp | lines | parse -r "(.*)"
arp | lines | parse -r "(.*)(.*)"
arp | lines | parse -r "(.*) (.*)"
arp | lines | parse -r "(.*) (.*) (.*)"
arp | lines | parse -r "(.*)\\s*(.*) (.*)"
arp | lines | parse -r "(.*)\\s*(.*)\\s*(.*)"
arp | detect columns
arp | detect columns | drop Mask
arp | detect columns 
arp | detect columns | drop Mask
arp | detect columns | drop "Mask"\
arp | detect columns | drop 6
arp | detect columns | drop column Mask
arp | detect columns | drop column 6
arp | detect columns | drop column  -h | bat
arp | detect columns | reject Masks
arp | detect columns | reject Mask
$d
$data
ip a
arp a
arg
arp
sudo arp-scan -l
nmap -h | bat
ip a
nmap -sn 192.168.1.108/24
gobuster
tldr gobuster
gobuster https://www.google.com
gobuster dir "https://www.google.com"
man gobuster 
gobuster --help
rustup
dnfs rustup
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
ls
setxkbmap us dvorak
startup
sudo light -S 20
startup
ls
ls | skip 3 | drop 2
ps 
sudo fdisk -l\
sudo fdisk -l
sudo fdisk -l | lines
sudo fdisk -l | lines | drop 7 | skip  -h | bat
sudo fdisk -l | lines | enumerate
drop -h | bat
get  -h | bat
sudo fdisk -l | lines | get 8..11
sudo fdisk -l | lines | get 8.11
sudo fdisk -l | lines | range 7.. 12
sudo fdisk -l | lines | range 7..12
sudo fdisk -l | lines 
sudo fdisk -l | lines | range 8..11
split
split -h | bat
sudo fdisk -l | lines | range 8..11 | split column
sudo fdisk -l | lines | range 8..11 | split column ' '
sudo fdisk -l | lines | range 8..11 | split column -c' '
sudo fdisk -l | lines | range 8..11 | split column -c ' '
sudo fdisk -l | lines | range 8..11 | split words
sudo fdisk -l | lines | range 8..11 | split row
sudo fdisk -l | lines | range 8..11 | split row ' '
sudo fdisk -l | lines | range 8..11 | split list
sudo fdisk -l | lines | range 8..11 | split list ' '
sudo fdisk -l | lines | range 8..11 | split column -cr "\s*"
sudo fdisk -l | lines | range 8..11 | split column -cr "\\s*"
sudo fdisk -l | lines | range 8..11 | split column -cr "\\s"
sudo fdisk -l | lines | range 8..11 | split column -c "\\s"
sudo fdisk -l | lines | range 8..11 | split column -c " "
sudo fdisk -l | lines | range 8..11 | parse
sudo fdisk -l | lines | range 8..11 | detect columns
sudo fdisk -l | lines | range 8..11 | str join
sudo fdisk -l | lines | range 8..11 | str join "\n"
sudo fdisk -l | lines | range 8..11 | str join "\n" | detect columns
sudo fdisk -l | lines | range 8..11 | split column " "
sudo fdisk -l | lines | range 8..11 | split column -c " "
sudo fdisk -l | lines | range 8..11 
table -h | bat
sudo fdisk -l | lines | range 8..11 | table
sudo fdisk -l | lines | range 8..11 
column 
column  -h | bat
sudo fdisk -l | lines | range 8..11 | column 
sudo fdisk -l | lines | range 8..11 | column -t
sudo fdisk -l | lines | range 8..11 | columns
sudo fdisk -l | lines | range 8..11 | headers
"a b c | 1 2 3" | split row "|"
"a b c |<\n>1 2 3" | split row "|"
"a b c |1 2 3" | split row "|"
"a b c |1 2 3" | split row "|" | split column 
"a b c |1 2 3" | split row "|" | split column " "
"a b c |1 2 3" | split row "|" | split column -c  " "
"a b c |1 2 3" | split row "|" | split column -c " "
"a b c |1 2 3" | split row "|" | split column -c " " | header
"a b c |1 2 3" | split row "|" | split column -c " " | headers
sudo fdisk -l | lines | range 8..11 
sudo fdisk -l | lines | range 8..11 | split column -c " "
sudo fdisk -l | lines | range 8..11 | split column -c " " |headers
sudo fdisk -l
sudo fdisk -l |lines 
sudo fdisk -l |lines | range 8..1
sudo fdisk -l |lines | range 8..11
sudo fdisk -l |lines | range 8..11 | split column -c " "
sudo fdisk -l |lines | range 8..11 | split column -c " " | headers
dnfs vmware
vmware-uninstall
vmware-uninstall -l
vmware-installer -l
dnfr vmware-player
vmware-uninstall vmware-player
vmware-installer -u vmware-player
sudo vmware-installer -u vmware-player
killall emacs
^emacs --daemon
dnfs virtualbox
dnfs oracle vm
sudo dnf -y install @development-tools<\n>sudo dnf -y install kernel-headers kernel-devel dkms elfutils-libelf-devel qt5-qtx11extras
wget -q https://www.virtualbox.org/download/oracle_vbox.asc<\n>sudo rpm --import oracle_vbox.asc
sudo vi /etc/yum.repos.d/virtualbox.repo
sudo dnf -y install VirtualBox-6.1
sudo dnf -y install VirtualBox
dnfs virtualbox
sudo vi /etc/yum.repos.d/virtualbox.repo
sudo rm /etc/yum.repos.d/virtualbox.repo
ls
dnfs virtualbox
sudo dnf install VirtualBox-7.0
yum install VirtualBox-6.1
sudo yum install VirtualBox-6.1
sudo rpm --import oracle_vbox_2016.asc
wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | rpm --import -
wget https://download.virtualbox.org/virtualbox/rpm/fedora/virtualbox.repo
sudo mv virtualbox.repo /etc/yum.repos.d/
sudo dnf update
dnfs virtualbox
dnfi virtualbox-7.0
dnfi virtualbox-7.0.x86_64
dnfi VirtualBox-7.0
dnfu
ls
alias
ps 
sudo fdisk -l 
startup
sudo fdisk -l 
sudo fdisk -l | linus
sudo fdisk -l | lines
sudo fdisk -l | lines | range 8..14
sudo fdisk -l | lines | range 8..14|headers
sudo fdisk -l | lines | range 8..14 | split column -c ' '
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | hearder
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | hearders
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | where Size > 1
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | get size
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | get size | into filesize 
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | get size | into filesize | where $in > 1GB
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | get size | into filesize | where {|x| $x > 1GB}
update  -h | bat
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers<\n>
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | update size {|x| $x | into filesize }
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | update Size {|x| $x | into filesize }
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | update Size {|x| $x.Size | into filesize }
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | update {|x| $x.Size | into filesize }
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | update Size { into filesize }
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers 
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | update Size {|| into filesize }
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | update Size {|| into filesize } | update Device {|| into bool }
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | update Size {|| into filesize } 
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | update Size {|| into filesize } | where Size < 1GB
sudo fdisk -l | lines | range 8..14 | split column  ' ' | headers | update Size {|| into filesize } | where Size < 1GB
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | update Size {|| into filesize } | where Size < 1GB
ps 
sudo fdisk -l
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | update Size { into filesize } | where Size < 1GB
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers 
sudo fdisk -l | lines | range 8..14 | split column -c ' ' | headers | where Type == Linux
ls
sudo fdisk -l
sudo fdisk -l | find '/dev'
sudo fdisk -l | find '^/dev'
sudo fdisk -l | find -r '^/dev'
sudo fdisk -l | find -r  "^/dev"
sudo fdisk -l | find -r  "^\/dev"
sudo fdisk -l | find -r  "/dev"
sudo fdisk -l | find -rm  "^/dev"
sudo fdisk -l | find -mr  "^/dev"
sudo fdisk -l | find -mr  "^/dev.*"
sudo fdisk -l | find -m "^/dev"
sudo fdisk -l | find -m "^\/dev"
sudo fdisk -l | find -rm "^\/dev"
sudo fdisk -l | find -mr "^\/dev"
sudo fdisk -l | find -m "^/dev"
sudo fdisk -l | find -m "^"
sudo fdisk -l | find -m ""
sudo fdisk -l | find -m "s"
sudo fdisk -l | find -m "\^"
sudo fdisk -l | find -mr "^"
sudo fdisk -l | find -mr "^$"
^skip -h | bat
skip -h | bat
wc
"hasa oeu anoesu as" | wc -l
"hasa oeu anoesu as" | wc 
^ls | wc
^ls | wc -l
^ls 
wc -h | bat
man wc
^ls | wc -w
^ls | lines
ls | lines
ls 
ls | get name
ls | sort -h | bat
ls | sort-by -h | bat
ls | sort-by name
ls | sort-by size
ls | sort-by -r  size
syncthing
startup
ls 
ls | where $in =~ "BYOB"
ls | where name =~ "BYOB"
ls | where name =~ "BYOB" | get name
ls | where name =~ "BYOB" | get name 
ls | where name =~ "BYOB" | get name | str trim  -h | bat
ls | where name =~ "BYOB" | get name | str trim -l "BYOB_"
ls | where name =~ "BYOB" | get name | str trim -l "BYOB"
ls | where name =~ "BYOB" | get name | each {str trim -l "BYOB_"}
str -h | bat
str substring 
str substring  -h | bat
ls | where name =~ "BYOB" | get name | each {str substring 6..}
ls | where name =~ "BYOB" | get name | each {str substring 5..}
ls | where name =~ "BYOB" | get name | each {|x| mv $x ($x | str substring 5..)}
ls
syncthing
startup
syncthing
find -h
^find  -h | bat
^find  --help | bat
sudo dnf search fd
sudo dnf search fd-find
grep -h | bat
grep --help
rg  -h | bat
man find
tldr find
find --help
^find --help
find -not 
^find -not 
ls **/*
ls **/* | where type == file | find -v /Music /Videos /Pictures | fzf
ls **/* | where type == file | find -v /Music /Videos /Pictures | get name | fzf
^ls **/* | where type == file | find -v /Music /Videos /Pictures | get name | fzf
ls **/* | where type == file | find -v /Music /Videos /Pictures | get name | to text | fzf
ls **/* | where type == file | find -v "/Music" | get name | to text | fzf
ls **/* | where type == file | find -v "/Music" | get name | to text 
ls **/* | where type == file | find -v "/Music" | get name 
find  -h | bat
ls
ls | find -v Pictures
ls **/* | where type == file | find -v "Music" | get name | to text
ls **/* | where type == file | find -v "Music" "Pictures" | get name | to text
ls **/* | where type == file | find -v "Music" "Pictures" "Videos" | get name | to text
ls **/* | where type == file | find -v "Music" "Pictures" "Videos" "Documents" | get name | to text
ls **/* | where type == dir
ls
ls **/* | where type == file | find -v 'Music' 'Pictures' 'Videos' 'Documents' | get name | to text | fzf
ls **/* | where type == file | find -v 'Music' 'Pictures' 'Videos' 'Documents' 'Books' | get name | to text | fzf
cd ~
dnfs gimp
dnfi gimp
startupk
startup
ps -l 
ps -l | find emacs
startup
xset  -h | bat
tldr xset
ls **/* | where type == file | find -v 'Music' 'Pictures' 'Videos' 'Documents' 'Books' | get name | to text | fzf
cargo run
emacs --nw
ls
emacsclient  -h | bat
ls
dnfs carapace
cd ~
ls
ls **/* | where type == file | find -v 'Music' 'Pictures' 'Videos' 'Documents' 'Books' | get name | to text | fzf
cd =
cd 
cd /
ls
cd ~
ls **/* | where type == file | find -v 'Music' 'Pictures' 'Videos' 'Documents' 'Books' | get name | to text | fzf
ls
dnfi carapace-bin_0.25.0_linux_386.rpm
ls
carapace
carapace _carapace nushell
$env.config
dnfu
ls
http get  -h | bat
mkdir test
md testing
http get https://github.com/rsteube/carapace-bin/releases/download/v0.25.0/carapace-bin_0.25.0_linux_386.rpm
curl  -h | bat
wget  -h | bat
curl -h
curl -O -h
curl -O https://github.com/rsteube/carapace-bin/releases/download/v0.25.0/carapace-bin_0.25.0_linux_386.rpm
curl -h
http get  -h | bat
curl -h
wget -h
man wget
man curl
tldr curl
http get https://github.com/rsteube/carapace-bin/releases/download/v0.25.0/carapace-bin_0.25.0_linux_386.rpm | save carapace.rpm
fetch  -h | bat
tldr wget
wget  -h | bat
wget https://github.com/rsteube/carapace-bin/releases/download/v0.25.0/carapace-bin_0.25.0_linux_386.rpm
cd 
cargo run
ls
cd src
l
ls
cargo run
lsof  -h | bat
man lsof
sudo lsof -i :7878<\n>
sudo lsof -i :7878
ls
cargo run=
cargo run
rustdco
rustdoc
tldr rustdoc
syncthing
startup
ls 
ls | get name 
str downcase  -h | bat 
ls | get name | each {|x| mv $x ($x | str downcase)}
mv -h | bat
ls
ls | find averse
ls | get name | each {|x| mv -f $x ($x | str downcase)}
ls
ls
mkdir test
cp * test
cp ./* test
tldr cp
cp * test
cp * test/
cp *.* test/
ls
ls *
ls | get name | each {|x| mv -f $x ($x | str replace "byob_" " ")}
ls | get name | where $in =~ byob | each {|x| mv -f $x ($x | str replace "byob_" " ")}
ls | get name | where {|x| $x =~ byob} | each {|x| mv -f $x ($x | str replace "byob_" " ")}
ls
ls | get name | where {|x| $x =~ " "} | each {|x| mv -f $x ($x | str replace " " "")}
latexmk
startup
